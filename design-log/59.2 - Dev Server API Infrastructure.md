# 59.2 - Generic Dev Server Design API

## Context
As part of the [Vendor Adapter Architecture (Log 59)](./59%20-%20Server-Side%20Figma%20Conversion%20and%20Bi-directional%20Sync.md), the Jay Dev Server must expose a generic API to handle design files from multiple vendors (Figma, Wix, etc.).

This log details the design for **Phase 2: Generic Dev Server API**.

## Goals
1.  **Vendor Routing:** Dynamically route requests to the correct Vendor Adapter.
2.  **Storage Standard:** Define where and how vendor-specific JSON files are stored.
3.  **Extensibility:** Allow adding new vendors without changing the core API structure.

## API Design

### Base Path: `/api/design`

#### `POST /api/design/:vendorId/export`
*   **Params:** `vendorId` (e.g., 'figma', 'wix')
*   **Payload:** `{ pageUrl: string, data: any }`
*   **Behavior:**
    1.  Validate `vendorId` against registered adapters.
    2.  Delegate validation of `data` to the specific Adapter.
    3.  Resolve file path from `pageUrl`: `src/pages/[...urlPath]/page.[vendorId].json`.
    4.  Save file.
    5.  **Trigger:** Call `adapter.convert(data)` to generate `page.jay-html`.
    6.  Return `200 OK`.

#### `GET /api/design/:vendorId/import`
*   **Query:** `?url=pageUrl`
*   **Behavior:**
    1.  Resolve file path from `url`: `src/pages/[...urlPath]/page.[vendorId].json`.
    2.  Read file.
    3.  Return JSON payload.

## Adapter Interface
We need a TypeScript interface that all Server-Side Adapters must implement.

```typescript
export interface VendorAdapter {
    vendorId: string;
    
    /**
     * Converts the raw vendor JSON into a Jay HTML string.
     */
    convert(data: any): Promise<string>;
    
    /**
     * Optional: Validate the payload structure before saving.
     */
    validate?(data: any): boolean;
}
```

## Storage Strategy
We will store vendor source files alongside the generated code to keep the page unit self-contained.

Example Structure:
```text
src/pages/
  home/
    page.ts           (Controller/Contract)
    page.jay-html     (Generated View)
    page.figma.json   (Figma Source)
    page.wix.json     (Wix Source - hypothetical)
```

## Implementation Plan
1.  Create `DesignController` in `jay-dev-server`.
2.  Implement the dynamic routing logic.
3.  Create a simple `AdapterRegistry` to manage available adapters.
4.  Register the routes in the Express app.

## Adapter Registry Architecture

To support the goal of extensibility and loose coupling, we will use a **Singleton Registry Pattern** for managing vendor adapters.

### 1. The Registry Class
The `AdapterRegistry` acts as the central lookup table. It is responsible for:
*   Storing registered adapter instances keyed by `vendorId`.
*   Providing a safe access method that throws 400-series errors if an adapter is missing.
*   Preventing duplicate registrations for the same vendor.

```typescript
export class AdapterRegistry {
    private adapters = new Map<string, VendorAdapter>();

    register(adapter: VendorAdapter) {
        if (this.adapters.has(adapter.vendorId)) {
            throw new Error(`Adapter for ${adapter.vendorId} already registered`);
        }
        this.adapters.set(adapter.vendorId, adapter);
    }

    get(vendorId: string): VendorAdapter {
        const adapter = this.adapters.get(vendorId);
        if (!adapter) {
            throw new Error(`No adapter found for vendor: ${vendorId}`);
        }
        return adapter;
    }
}

export const designAdapterRegistry = new AdapterRegistry();
```

### 2. Registration Flow (Startup)
Adapters should register themselves during the server bootstrap phase. This effectively "plugins" the capability without modifying the core `DesignController`.

In `jay-dev-server/src/index.ts` (or equivalent startup file):

```typescript
// 1. Import Adapters
import { FigmaAdapter } from './vendors/figma/adapter';
// import { WixAdapter } from './vendors/wix/adapter';

// 2. Register
designAdapterRegistry.register(new FigmaAdapter());
// designAdapterRegistry.register(new WixAdapter()); // Future

// 3. Initialize Controller
// The controller will use `designAdapterRegistry.get(vendorId)` internally.
```

### 3. Benefits of this approach
*   **Zero-Touch Core:** Adding a new vendor doesn't require changing the `DesignController` or the API routing logic. You just register a new class instance.
*   **Lazy Loading (Optional):** If adapter bundles become large, we can change `register` to accept a factory function or a dynamic `import()` path, loading the adapter code only when the first request for that vendor arrives.
