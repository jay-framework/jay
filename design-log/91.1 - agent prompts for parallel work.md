# Agent Prompts for Parallel Work on Jay-HTML to Figma Conversion

**Context:** Design Log #91.1 documents the current gaps. These 3 prompts are designed for 3 agents to work in parallel. Each agent should read the referenced design logs and code before starting work.

---

## Prompt 1: Fix the Fixable Gaps (TDD Approach)

```
## Task: Fix Category A Conversion Gaps via TDD

Read these design logs first:
- design-log/91.1 - jay-html to figma conversion gaps and development state.md
- design-log/90 - jay-html to vendor doc conversion on import.md

Read the converter code:
- packages/jay-stack/stack-cli/lib/vendors/figma/converters/from-jay-html.ts

Read the test file and understand the fixture-based testing approach:
- packages/jay-stack/stack-cli/test/vendors/figma/from-jay-html.test.ts

Look at existing fixtures for the pattern:
- packages/jay-stack/stack-cli/test/vendors/figma/from-jay-html-fixtures/

### Critical Rules

1. **NO FALSE GREENS** — Read .cursor/rules/no-false-green-tests.md. Every expected.figma.json must reflect the CORRECT output, not the current buggy output. If you don't know what the correct output is, ASK.
2. **Test first, then fix** — Create the test fixture with the correct expected output (it will be RED). Then fix the converter to make it GREEN.
3. **One gap at a time** — Fix one gap, run the full test suite, confirm no regressions, then move to the next.
4. **Document your work** — After each fix, briefly note what you changed and why in design-log/91.1 under an "Implementation Results" section.

### Gaps to fix (in this order):

**1. Layout Sizing Values (A1)** — ~47 nodes affected
- Create fixture `layout-sizing-fixed-vs-fill/` with elements that should be FIXED (explicit pixel width) vs FILL (flex-grow/width:100%)
- The CSS signals: `width: Npx` inside a flex parent → FIXED. `flex-grow: 1` or no explicit width with `align-self: stretch` → FILL.
- Fix the `stylesToFigmaProps` function to correctly distinguish FIXED vs FILL.

**2. Text Defaults (A2)** — ~45 text nodes
- Create fixture `text-defaults/` with a basic text element
- Expected should include: textAlignVertical: "TOP", letterSpacing: { value: 0, unit: "PERCENT" }, textCase: "ORIGINAL", textTruncation: "DISABLED", textAutoResize: "WIDTH_AND_HEIGHT"
- Fix `convertTextElement` and `tryCollapseTextWrapper` to always emit these Figma defaults

**3. Per-Side Stroke Weights (A3)** — ~42 nodes
- Create fixture `stroke-per-side/` with elements using border-bottom, border-top, etc.
- Expected should have strokeTopWeight, strokeRightWeight, etc. and strokeAlign: "INSIDE"
- Fix the CSS border parsing to extract per-side weights

**4. Node Naming (A4)** — ~72 nodes
- Check if the forward converter (Figma→HTML) preserves the name in data-name for all nodes
- If not, investigate if we can improve the forward converter
- For the reverse converter, ensure data-name is always used when present
- Create fixture `node-naming-detailed/` with various data-name patterns

**5. Font Style Edge Case (A5)** — 1 node
- Check the font-style-mapping fixture — does it cover weight 800 + italic?
- If not, add a test case for it and fix fontWeightAndStyleToFigmaStyle

**6. strokeAlign (A6)** — ~42 nodes
- Add strokeAlign: "INSIDE" emission whenever strokes are present
- Can be combined with the per-side stroke weights fixture

### Running tests

From packages/jay-stack/stack-cli:
npx vitest run test/vendors/figma/from-jay-html.test.ts

### Remember

You are building an algorithm that needs to work correctly for real jay-html files, not just pass tests. Think about edge cases. Think about what the CSS actually means. Don't hardcode values to pass a specific test — implement the general rule.
```

---

## Prompt 2: Research Non-Reconstructable Gaps (Category B)

```
## Task: Research Category B Gaps — Deep Investigation & Discussion

Read these design logs first:
- design-log/91.1 - jay-html to figma conversion gaps and development state.md
- design-log/91 - figma property comparison strategy for roundtrip testing.md
- design-log/90 - jay-html to vendor doc conversion on import.md

Read the actual vs expected output for the product page:
- packages/jay-stack/stack-cli/test/vendors/figma/from-jay-html-fixtures/wix-store-product-page/actual-output.figma.json
- packages/jay-stack/stack-cli/test/vendors/figma/from-jay-html-fixtures/wix-store-product-page/expected.figma.json

### Your Goal

Investigate each Category B gap in depth. For EACH gap, produce:
1. What exactly the gap is (with concrete examples from the product page files)
2. Whether it is TRULY not reconstructable, or just hard
3. Possible approaches to fix it, with trade-offs
4. Your recommendation

### Gaps to investigate:

**B1. Parent/Tree Metadata** (parentId, parentType, etc.)
- These are computable from the tree structure itself. Is it worth computing them?
- Would it simplify the comparison if the converter just added them?

**B2. Editor State** (visible, locked, isMask, blendMode)
- Are these always the same defaults? If so, should we just emit the defaults?
- What about nodes that ARE hidden in Figma? How does the forward converter handle them?

**B3. Layout Computed Properties** (THIS IS THE KEY ONE)
- `layoutPositioning` — can we derive from CSS `position: absolute` vs `position: relative`?
- `layoutGrow` — can we derive from CSS `flex-grow`?
- `layoutAlign` — can we derive from CSS `align-self`?
- `layoutWrap` — we already handle flex-wrap, but is it complete?
- `absoluteRenderBounds` — this requires a full layout engine. Options:
  a) Skip it (acceptable loss)
  b) Use a headless browser (Playwright/Puppeteer) to render the jay-html and extract computed layout
  c) Implement a simplified layout calculator
- For option (b): What would the architecture look like? The converter runs during `onImport` — can it shell out to a headless browser? What are the performance implications?

**B4. Fill/Stroke defaults** (blendMode, visible, boundVariables)
- Should the converter emit these as constants? It makes the output more "Figma-like" but adds properties that serve no purpose.
- Or should the test comparison strip them?

**B5. Coordinates**
- Auto-layout children in Figma have x/y set by the layout engine. The converter uses 0,0.
- Is there value in computing approximate positions? Or is this pure Figma metadata?

**B6. Root dimensions**
- Can we compute the actual content dimensions from the HTML/CSS? The converter uses 1440x900 defaults.

### Important

- Do NOT just list the gaps — investigate them deeply. Read the actual code and data.
- For each gap, think about what the RIGHT solution is for an algorithm that needs to work in production.
- Consider both the roundtrip case (Figma->HTML->Figma) and the forward-only case (HTML->Figma for files that were never in Figma).
- The headless browser approach (B3) is particularly important — research how Playwright/Puppeteer can extract computed layout bounds and whether this is feasible in the converter pipeline.
- Document all findings in design-log/91.1 under a new "Category B Research Results" section.
- Present your findings to the user for discussion — do NOT make implementation decisions unilaterally.
```

---

## Prompt 3: Research Non-Figma-Sourced Jay-HTML Conversion

```
## Task: Investigate Converting Jay-HTML That Was NOT Exported from Figma

Read these design logs first:
- design-log/91.1 - jay-html to figma conversion gaps and development state.md
- design-log/90 - jay-html to vendor doc conversion on import.md

### Background

The current converter and tests focus on the ROUNDTRIP case: jay-html that was originally exported from Figma (via the plugin's forward converter). This jay-html has Figma-specific attributes like `data-figma-id`, `data-figma-type`, `data-name`, and inline styles that mirror Figma's CSS output.

But there's another critical use case: jay-html files written by hand, by AI, or by other tools — files that were NEVER in Figma. These files:
- Use CSS classes and external stylesheets (not just inline styles)
- Use semantic HTML (header, nav, article, section, footer) not just div
- Use CSS variables (var(--bg-primary))
- Use CSS grid (grid-template-columns), not just flexbox
- Have no data-figma-id or data-figma-type attributes
- May use CSS transitions, hover states, media queries
- Reference linked stylesheets

### Your Task

**1. Create test fixtures**
Look at real non-Figma-sourced jay-html files in the jay-framework/wix workspace:
- examples/store/src/pages/cart/page.jay-html (complex cart page with CSS classes, grid layout, CSS vars)
- examples/store/src/pages/categories/[slug]/page.jay-html (category page with breadcrumbs, grid)
- examples/whisky-store/src/pages/products/[slug]/page.jay-html (product detail)

Pick a SIMPLE subset from one of these files (e.g., just the header, or just a single card component) and create a test fixture for it:
- packages/jay-stack/stack-cli/test/vendors/figma/from-jay-html-fixtures/non-figma-source-basic/
  - input.jay-html — a simplified version using CSS classes and external styles
  - expected.figma.json — what the CORRECT Figma output should be

**DO NOT make the expected a copy of the current output. Think carefully about what Figma structure this HTML SHOULD produce.**

**2. Identify the gaps**
Run the test (it will fail). Compare actual vs expected. Categorize the gaps specific to non-Figma-sourced files:
- How does the converter handle CSS classes? (It currently only parses inline styles)
- How does external stylesheet resolution work (or fail)?
- How does semantic HTML mapping work? (header -> ?, nav -> ?, article -> ?)
- How are CSS variables resolved?
- How is CSS grid handled? (Figma doesn't have grid layout)

**3. Propose an approach**
For each gap, propose how it could be addressed:
- CSS class resolution: parse the <style> block and linked stylesheets, resolve computed styles per element
- CSS grid: convert to closest Figma equivalent (auto-layout with wrapping?)
- CSS variables: resolve at conversion time from the stylesheet
- Semantic HTML: map to meaningful Figma frames with appropriate naming

**4. Consider the headless browser approach**
For non-Figma-sourced files, a headless browser might be MORE valuable than for roundtrip files, because:
- CSS classes + external stylesheets need full cascade resolution
- CSS grid needs layout computation
- CSS variables need resolution
- Media queries need viewport context

Would rendering in a headless browser and extracting computed styles + layout be the right approach for this case?

### Important

- This is RESEARCH, not implementation. Create the test fixture and document findings.
- Think about this as building a general-purpose HTML-to-Figma converter, not just a roundtrip tool.
- The algorithm must work correctly — don't cut corners to make tests pass.
- Document all findings in design-log/91.1 under a new "Non-Figma-Source Research" section.
- Focus on understanding the GAPS first. Implementation comes later.
- Compare the structure of non-Figma jay-html vs Figma-exported jay-html to clearly articulate the differences the converter needs to handle.
```

---

## How to Use These Prompts

1. Start all 3 agents in parallel
2. Agent 1 will produce code changes (test fixtures + converter fixes) — review and commit incrementally
3. Agent 2 will produce a research document for discussion — review findings before any implementation
4. Agent 3 will produce a test fixture + research document — review the fixture design carefully

All 3 agents should be updating design-log/91.1 with their findings. Coordinate to avoid conflicts in that file.
