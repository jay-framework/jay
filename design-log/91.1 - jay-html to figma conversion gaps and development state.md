# Design Log #91.1 - Jay-HTML to Figma Conversion: Gaps Inventory & Development State

**Related:** Design Log #90 (initial design), #91 (property comparison strategy), #92 (component sets)

## Current State (2026-02-13)

The `convertJayHtmlToFigmaDoc` converter handles the roundtrip path: Figma export -> jay-html -> FigmaVendorDocument. A focused test suite validates individual conversion features against hand-crafted fixtures.

### Test Suite Status

| Test                   | Status | Description                                           |
| ---------------------- | ------ | ----------------------------------------------------- |
| hello-world            | GREEN  | Basic text + frame                                    |
| background-fills       | GREEN  | Solid colors, gradients                               |
| strokes-borders        | GREEN  | Border colors/widths                                  |
| effects                | GREEN  | Shadows, blur                                         |
| layout-sizing          | GREEN  | Flex sizing                                           |
| overflow-clipping      | GREEN  | Overflow hidden/scroll                                |
| border-radius          | GREEN  | Per-corner radius                                     |
| font-style-mapping     | GREEN  | fontWeight -> fontName.style                          |
| node-naming            | GREEN  | data-name, data-figma-type naming                     |
| node-type-image        | GREEN  | img -> RECTANGLE with IMAGE fills                     |
| node-type-vector       | GREEN  | data-figma-type=vector -> VECTOR with svgContent      |
| text-nesting           | GREEN  | div>div(text) collapse to TEXT                        |
| text-styles            | GREEN  | fontSize, textAlign, letterSpacing, lineHeight        |
| min-max-dimensions     | GREEN  | min/max width/height                                  |
| component-set-enum     | GREEN  | if conditions -> COMPONENT_SET + COMPONENT + INSTANCE |
| wix-store-product-page | RED    | Full roundtrip integration test                       |

**15 green, 1 red.** All focused tests pass. The integration test (real product page roundtrip) fails due to the gaps listed below.

### What's Implemented

- CSS inline style parsing (all common properties)
- Layout: flex-direction, gap, padding, alignment, sizing
- Visual: fills (solid + gradient), strokes, corner radius, opacity, effects
- Text: font family/weight/style, size, alignment, decoration, line-height, letter-spacing
- Node types: FRAME, TEXT, SECTION, RECTANGLE (image), VECTOR, GROUP
- Structural: Component sets from `if` conditions with contract-aware variant detection
- Jay plugin data: forEach, if, ref, data-figma-id, data-figma-type, headlessImports, semanticHtml

---

## Gap Inventory

### Category A: Fixable in Converter (derivable from CSS/HTML)

These gaps represent information present in the jay-html that the converter currently fails to extract.

#### A1. Layout Sizing Values (~47 nodes)

**Problem:** Converter produces `layoutSizingHorizontal: "FILL"` where Figma export has `"FIXED"`.
**Root cause:** CSS `width: 100%` maps to `FILL`, but some nodes with explicit pixel widths inside flex containers should be `FIXED`. The heuristic for FILL vs FIXED needs refinement.
**CSS signals:** `width: Npx` (FIXED), `flex-grow: 1` / `width: 100%` (FILL), `align-self: stretch` (STRETCH).

#### A2. Missing Text Defaults (~45 text nodes)

**Problem:** Text nodes missing `textAlignVertical`, `letterSpacing`, `textCase`, `textTruncation`, `textAutoResize`.
**Root cause:** Converter only emits text properties when the CSS explicitly sets them. But Figma always emits these with default values.
**Fix approach:** Emit Figma defaults when CSS doesn't specify: `textAlignVertical: "TOP"`, `letterSpacing: { value: 0, unit: "PERCENT" }`, `textCase: "ORIGINAL"`, `textTruncation: "DISABLED"`, `textAutoResize: "WIDTH_AND_HEIGHT"`.

#### A3. Per-Side Stroke Weights (~42 nodes)

**Problem:** Converter only emits `strokeWeight` (uniform). Expected has `strokeTopWeight`, `strokeBottomWeight`, etc.
**Root cause:** CSS `border-bottom: 1px solid ...` already parsed into `strokes` + `strokeWeight` but individual side weights not extracted.
**CSS signals:** `border-top`, `border-right`, `border-bottom`, `border-left` -> per-side weights. `border: 1px` -> uniform (all sides equal). Also needs `strokeAlign: "INSIDE"` (CSS borders are always inside).

#### A4. Node Naming (~72 nodes)

**Problem:** Many nodes named `"Frame"` instead of their original Figma names (`"Frame 6"`, `"Home"`, etc.).
**Root cause:** The forward converter (Figma->HTML) stores names in `data-name`, but some nodes don't have `data-name` set, or the attribute is lost.
**Note:** This may require improving the forward converter to always preserve names. For reverse-only conversion (non-Figma source), names will necessarily be generic.

#### A5. Font Style Edge Cases (1 node)

**Problem:** "FashionHub" text gets `fontName.style: "Extra Bold"` but should be `"Extra Bold Italic"`.
**Root cause:** CSS has `font-style: italic` + `font-weight: 800`, but the italic detection may not combine correctly with weight 800.

#### A6. Missing `strokeAlign` (~42 nodes)

**Problem:** Converter doesn't emit `strokeAlign`. Figma defaults to `"INSIDE"`.
**Fix:** Always emit `strokeAlign: "INSIDE"` when strokes are present (CSS borders are inside by default).

---

### Category B: Figma Metadata (not reconstructable from HTML)

These properties exist in the Figma export but have no HTML/CSS equivalent. The roundtrip test's expected file needs to be normalized to exclude these, OR the test comparison needs to strip them.

#### B1. Parent/Tree Navigation Metadata (~305 nodes)

`parentId`, `parentType`, `parentLayoutMode`, `parentOverflowDirection`, `parentNumberOfFixedChildren`, `parentChildIndex`
**Why not fixable:** These describe the parent's properties from the child's perspective. Figma computes these at export time. HTML doesn't have this concept.

#### B2. Editor State Properties (~305 nodes)

`visible`, `locked`, `isMask`, `blendMode` (on nodes)
**Why not fixable:** These are Figma editor states (lock, visibility, mask). All exported nodes are visible and unlocked by definition.

#### B3. Layout Computed Properties (~304 nodes)

`layoutPositioning`, `layoutGrow`, `absoluteRenderBounds`, `layoutWrap`, `layoutAlign`
**Discussion:** Some of these ARE derivable from CSS in theory:

- `layoutWrap` -> CSS `flex-wrap` (already partially handled)
- `layoutAlign` -> CSS `align-self`
- `layoutGrow` -> CSS `flex-grow`
- `layoutPositioning` -> CSS `position: absolute` vs auto
- `absoluteRenderBounds` -> requires layout computation (headless browser or manual calc)

**Decision needed:** Should we implement `layoutGrow`, `layoutAlign`, `layoutPositioning` from CSS? These are meaningful layout properties. Or treat them as Figma metadata?

#### B4. Fill/Stroke Sub-Properties (~52 fill objects)

`blendMode: "NORMAL"`, `visible: true`, `boundVariables: {}` on each fill/stroke
**Why not fixable:** These are Figma defaults that don't correspond to CSS properties. The converter could emit them as constants, but they add noise.

#### B5. Absolute Coordinates vs Layout-Relative

Expected nodes have absolute canvas coordinates; converter produces layout-relative (0, 0) for auto-layout children.
**Why not fixable:** In auto-layout, child x/y is computed by Figma's layout engine. The converter only knows CSS relative positioning.

#### B6. Root Section Dimensions

Expected: `width: 2013, height: 1704`. Actual: `width: 1440, height: 900`.
**Discussion:** The converter uses 1440 (standard page width) and estimates height from children. Could be improved by computing actual content bounds.

#### B7. Node IDs

Expected: `424:366`. Actual: `jay-import:N`. Some nodes preserve original IDs via `data-figma-id`.
**Already partially handled:** Nodes with `data-figma-id` use the original ID.

---

### Category C: Structural Gaps

#### C1. Missing INSTANCE Nodes (~47 nodes)

Expected has INSTANCE nodes (component instances). Converter currently doesn't produce these for inline component usage.
**Note:** The component-set-enum test now generates INSTANCE nodes for `if`-based variants. But the product page has more complex component instance patterns (e.g., `sizeChoice`, `colorChoice`, shared header/footer components).

#### C2. Extra "Content" Wrapper Frame

Converter wraps body children in a "Content" FRAME. Expected doesn't have this wrapper.
**Root cause:** Design decision in the converter. May need to match the original structure when `data-figma-id` is available on the direct child.

#### C3. `bindingData` Top-Level Structure

Expected has `bindingData.layerBindings` mapping node IDs to contract tag paths. Converter doesn't produce this yet.
**Note:** This is a higher-level concern that connects the node tree to the contract. It's important for the plugin's binding UI but not for visual structure.

#### C4. Node Count Discrepancy (172 actual vs 305 expected)

133 fewer nodes in actual. Primary causes: missing INSTANCE nodes, and possibly elements not being converted or being collapsed incorrectly.

---

## Approach for the Integration Test

The `wix-store-product-page` expected file is currently a raw, unmodified Figma export. To make this test meaningful and passable, we need to:

1. **Create a "normalized expected"** that strips Category B properties (Figma metadata) from the expected file
2. **Fix Category A gaps** one at a time with dedicated focused tests
3. **Address Category C structural gaps** through design decisions

The goal is NOT to make the test pass by ignoring differences. It's to make the test compare what CAN be compared, and have it fail when the converter gets something WRONG — not when it can't produce Figma-only metadata.

---

## Open Questions

1. For Category B3 (layout computed properties like `layoutGrow`, `layoutAlign`): should these move to Category A? They are derivable from CSS.
2. For the roundtrip test: should we normalize the expected file once and commit it, or should the test dynamically strip properties at runtime?
3. For non-Figma-sourced jay-html (Category C scenario): should we create a parallel test suite, or extend the existing one?

---

## Category B Research Results (2026-02-14)

Deep investigation of each Category B gap. For each: what exactly the gap is, whether it's truly not reconstructable, approaches to fix, and recommendation.

### B1. Parent/Tree Navigation Metadata

**What:** `parentId`, `parentType`, `parentLayoutMode`, `parentOverflowDirection` — present on ~860 nodes in the expected file. `parentNumberOfFixedChildren` and `parentChildIndex` are NOT present in the expected file (despite being listed as gaps).

**Concrete examples from the product page:**

- Node `424:368` (FRAME "Home"): `parentId: "424:366"`, `parentType: "FRAME"`, `parentLayoutMode: "VERTICAL"`
- Node `I424:408;424:551` (RECTANGLE): `parentId: "424:408"`, `parentType: "INSTANCE"`

**Truly not reconstructable?** No — these are **trivially computable** from the tree structure. The converter builds the tree, so every child knows its parent's `id`, `type`, and `layoutMode`.

**Approaches:**

1. **Emit during conversion** — after building the tree, do a parent-linking pass that stamps `parentId`, `parentType`, `parentLayoutMode`, `parentOverflowDirection` on each child. ~20 lines of code.
2. **Strip from comparison** — exclude these from the test expected file since they're redundant metadata.

**Does the deserializer use these?** No. The Figma plugin deserializer builds the tree from `children` arrays via `appendChild()`. It never reads `parentId` or `parentType`. The forward converter (Figma→HTML) uses `parentType` and `parentLayoutMode` to determine CSS positioning, but those values come from the Figma API at export time, not from the serialized JSON.

**Recommendation: Strip from comparison.** These properties are redundant (derivable from tree structure), the deserializer doesn't read them, and computing them adds properties that serve no purpose in the import flow. The test should exclude them.

---

### B2. Editor State Properties

**What:** `visible`, `locked`, `isMask`, `blendMode` — present on all ~860 nodes.

**Concrete values in the product page:**
| Property | Distinct values | All same? |
|----------|----------------|-----------|
| `visible` | `true` only | Yes — all exported nodes are visible |
| `locked` | `false` only | Yes — all unlocked |
| `isMask` | `false` only | Yes — none are masks |
| `blendMode` | `"PASS_THROUGH"` only | Yes — all default |

**Truly not reconstructable?** Partially. The values are ALWAYS the same defaults for exported content. By definition, only visible nodes are exported to jay-html (hidden Figma layers don't appear in the HTML). The forward converter confirms this — it does NOT check `visible` and exports all nodes.

**Does the deserializer use these?**

- `visible`: **Yes** — `applyBaseProps()` sets `node.visible = doc.visible`
- `locked`: **Yes** — `applyBaseProps()` sets `node.locked = doc.locked`
- `blendMode`: **Yes** — `applyBaseProps()` sets `node.blendMode = doc.blendMode`
- `isMask`: **No** — not read or applied

**Approaches:**

1. **Emit constants** — add `visible: true`, `locked: false`, `blendMode: "PASS_THROUGH"` to every node. Ensures the deserializer applies correct defaults. ~5 lines of code.
2. **Let the deserializer default** — if these properties are missing, Figma API likely uses the same defaults. Test: skip a property and see if the Figma node has the right value.
3. **Strip from comparison** — since they're always the same defaults, exclude from test comparison.

**Recommendation: Emit `visible: true` and `locked: false` as constants.** These are cheap to add (2 properties per node), the deserializer reads them, and emitting them makes the converter output more complete. Skip `isMask` (not used) and `blendMode` (Figma's default for frames is already PASS_THROUGH). The test comparison can either include or strip these — they'll match either way.

---

### B3. Layout Computed Properties ⭐ THE KEY ONE

**What:** `layoutPositioning`, `layoutGrow`, `layoutAlign`, `layoutWrap`, `absoluteRenderBounds`.

**Data from the product page expected file:**

| Property               | Nodes | Non-default values                           |
| ---------------------- | ----- | -------------------------------------------- |
| `layoutPositioning`    | 859   | 1 node with `"ABSOLUTE"` (rest `"AUTO"`)     |
| `layoutGrow`           | 859   | None — all `0`                               |
| `layoutAlign`          | 859   | 40 nodes with `"STRETCH"` (rest `"INHERIT"`) |
| `layoutWrap`           | 54    | None — all `"NO_WRAP"`                       |
| `absoluteRenderBounds` | 859   | N/A (all computed)                           |

**Truly not reconstructable?** Most of these ARE reconstructable from CSS:

#### `layoutPositioning` → **MOVE TO CATEGORY A**

CSS `position: absolute` → `"ABSOLUTE"`. All other auto-layout children → `"AUTO"`.
The forward converter exports this: `layoutPositioning === 'ABSOLUTE'` → `position: absolute`.
The reverse converter already parses `position: absolute` for x/y but doesn't emit `layoutPositioning`.
The deserializer READS and APPLIES this property.
**Fix: ~3 lines** — check if `position === 'absolute'` and emit `layoutPositioning: "ABSOLUTE"`, else `"AUTO"`.

#### `layoutGrow` → **MOVE TO CATEGORY A** (but low priority)

CSS `flex-grow: N` → `layoutGrow: N`. The forward converter exports `flex-grow: ${node.layoutGrow}`.
The reverse converter already reads `flex-grow` for sizing decisions but doesn't emit `layoutGrow`.
The deserializer READS and APPLIES this property.
In this specific test fixture, all values are `0` (default), so the impact is zero for the roundtrip test. But for correctness and for other pages that use `flex-grow`, it should be emitted.
**Fix: ~3 lines** — read `flex-grow` value and emit as `layoutGrow`.

#### `layoutAlign` → **MOVE TO CATEGORY A**

CSS `align-self` → `layoutAlign`. The forward converter exports `align-self: stretch/center/flex-start/flex-end`.
The reverse converter already parses `align-self` into `layoutAlign` in `stylesToFigmaProps()` and emits it on frames. **However**, the actual output currently has NO `layoutAlign` values — this means either the CSS doesn't have `align-self` or the emitted value is being dropped somewhere.
40 nodes in the expected have `STRETCH` — these are meaningful layout properties that affect rendering.
The deserializer READS and APPLIES this property.
**Fix: Investigate why the converter's existing `align-self` → `layoutAlign` mapping isn't producing output. May need to also emit the `"INHERIT"` default.**

#### `layoutWrap` → **EMIT DEFAULT**

All 54 flex containers have `"NO_WRAP"`. The converter already handles `flex-wrap: wrap` → `WRAP`.
The deserializer likely applies this. Emitting `"NO_WRAP"` as default on flex containers is cheap.
**Fix: ~2 lines** — emit `layoutWrap: "NO_WRAP"` on all flex containers by default.

#### `absoluteRenderBounds` → **SKIP (acceptable loss)**

These are document-space coordinates computed by Figma's layout engine. Example:

- Node at local `x: 0, y: 0` inside a chain of nested frames → `absoluteRenderBounds: { x: 2503, y: -212, ... }`
- The bounds = cumulative parent offsets + local position.

**Options:**

1. **Skip it** — the deserializer does NOT read `absoluteRenderBounds`. Figma computes these automatically after node creation.
2. **Headless browser** — render the HTML, use `getBoundingClientRect()` to get absolute positions. This would be architecturally complex (the converter runs during `onImport` in a CLI context). It adds a Playwright/Puppeteer dependency. The result would still differ from Figma's layout engine output.
3. **Cumulative position calculator** — walk the tree, sum up parent x/y/padding/gap. Would give approximate results but miss many edge cases (alignment, spacing distribution, etc.).

**Recommendation: Skip `absoluteRenderBounds`.** The deserializer doesn't use it, Figma computes it automatically, and approximating it adds complexity for no import benefit. Strip from test comparison.

---

### B4. Fill/Stroke Sub-Properties

**What:** `blendMode`, `visible`, `boundVariables` inside fill/stroke objects.

**Concrete values in the product page:**

- `blendMode`: appears on 1 fill (the SECTION background) with value `"NORMAL"`. Most fills omit it.
- `visible`: appears on many fills, usually `true`. **Some fills have `visible: false`** — these are hidden fills in Figma (overlaid fills that are turned off).
- `boundVariables`: always `{}` when present (~48 fills). Empty object, no actual bindings.

**Does the deserializer use these?**

- `visible`: **Yes** — `toFill()` reads `fill.visible` and defaults to `true` if missing.
- `blendMode`: **No** — not read in `toFill()`.
- `boundVariables`: **No** — not read.

**The `visible: false` case is interesting.** The forward converter SKIPS fills with `visible === false` (line 455 in `utils.ts`). This means hidden fills never appear in the jay-html CSS. So in the roundtrip, these fills are genuinely lost — they existed in the original Figma but the HTML has no trace of them.

**Approaches:**

1. **Emit `visible: true`** on all fills the converter produces — since the converter only produces fills from CSS that was actually rendered, all produced fills are visible. This matches what the deserializer expects.
2. **Strip `boundVariables` and fill `blendMode`** from comparison — the deserializer ignores them, and emitting `{}` adds noise.
3. **Accept loss of hidden fills** — fills with `visible: false` in the original are lost in roundtrip. This is an acceptable loss since they had no visual effect.

**Recommendation: Emit `visible: true` on all fills.** Strip `boundVariables` and fill-level `blendMode` from comparison. Accept the loss of hidden fills as they have no visual effect.

---

### B5. Coordinates (x, y)

**What:** Auto-layout children get their x/y computed by Figma's layout engine. The converter produces `0, 0` for all auto-layout children.

**Concrete comparison from the product page:**

| Node ID | Expected x, y | Actual x, y | Match?                                            |
| ------- | ------------- | ----------- | ------------------------------------------------- |
| 424:366 | 100, 100      | 100, 100    | ✅ (absolute positioned, from CSS `left`/`top`)   |
| 424:368 | 0, 0          | 0, 0        | ✅ (first child, no offset)                       |
| 424:369 | 0.52, 0       | 0, 0        | ❌ (computed by layout — centered, slight offset) |
| 424:370 | 61.0, 19.3    | 0, 0        | ❌ (computed by layout — padding offset)          |
| 424:391 | 24.4, -0.3    | 24.4, -0.3  | ✅ (ABSOLUTE positioned, from CSS `left`/`top`)   |

**Pattern:** Nodes with explicit CSS `position: absolute` + `left`/`top` → correct x/y. Auto-layout children → always 0, 0 in actual.

**Truly not reconstructable?** Partially:

- **ABSOLUTE nodes**: Already correct — x/y comes from CSS `left`/`top`.
- **AUTO children**: Their x/y depends on parent padding, item spacing, sibling sizes, and alignment. Computing this requires a full flexbox layout engine.

**Does the deserializer use x/y?** Yes — it sets `node.x = doc.x` and `node.y = doc.y`. But for auto-layout children, Figma's layout engine overrides these values immediately. The x/y only matters for absolutely positioned children and for nodes in non-auto-layout parents.

**Approaches:**

1. **Accept 0,0 for auto-layout children** — Figma will compute the correct positions. The deserializer sets them but Figma overrides them.
2. **Approximate positions** — sum parent padding + gap \* index. Would only work for simple cases.
3. **Headless browser** — `getBoundingClientRect()` gives absolute positions. But these are viewport-relative, not parent-relative, and would need translation.

**Recommendation: Accept 0,0 for auto-layout children.** Figma overrides these positions during layout. The only x/y that matters are for ABSOLUTE nodes, which are already correct. Strip auto-layout children's x/y from comparison, or accept the mismatch as acceptable.

---

### B6. Root Section Dimensions

**What:** Expected root SECTION: `width: 2013, height: 1704`. Actual: `width: 1440, height: 900`.

**Investigation of the jay-html:**

- No explicit width/height on `<html>` or `<body>`.
- Main content frame (424:366) has `width: 100%` and `height: 760.68px`.
- Widest explicit child: `1097.95px`.
- The SECTION in Figma is 2013×1704 because it includes COMPONENT_SET nodes as siblings to the main frame, expanding the section bounds.

**Can we compute correct dimensions?**

- **Width**: The 2013px comes from the SECTION containing the main frame (1099px at x:100) PLUS component sets laid out beside it. Without knowing component set positions, we can't compute this.
- **Height**: 1704px similarly includes component sets vertically.
- **Content-only minimum**: ~1198×861 (100px offset + content). But this doesn't match the original either.

**Does the deserializer use these?** Yes — section width/height are set. But Figma sections auto-resize to fit their contents after children are placed. The initial dimensions are overridden.

**Approaches:**

1. **Content-based estimate** — compute from children's max(x + width, y + height) plus margin. Would give ~1200×900 instead of 1440×900.
2. **Keep 1440 default** — standard web page width. Height from content.
3. **Accept mismatch** — Figma section auto-resizes after import.

**Recommendation: Improve height computation, accept width mismatch.** The `computeContentHeight` function already exists — make it also compute width from children. Use these as initial dimensions. The exact values don't matter much because Figma sections auto-resize. Strip root section dimensions from strict comparison.

---

### Summary: Recommendations

| Gap                                       | Verdict          | Action                                                                     |
| ----------------------------------------- | ---------------- | -------------------------------------------------------------------------- |
| **B1** Parent metadata                    | Strip            | Not consumed by deserializer. Redundant. Strip from comparison.            |
| **B2** Editor state                       | Emit defaults    | Emit `visible: true`, `locked: false`. Skip `isMask`, `blendMode`.         |
| **B3** `layoutPositioning`                | **→ Category A** | Emit from CSS `position: absolute`. ~3 lines.                              |
| **B3** `layoutGrow`                       | **→ Category A** | Emit from CSS `flex-grow`. ~3 lines. Low priority (all 0 in this fixture). |
| **B3** `layoutAlign`                      | **→ Category A** | Already partially implemented. Debug why not emitting.                     |
| **B3** `layoutWrap`                       | Emit default     | Emit `"NO_WRAP"` on flex containers. Already handles `"WRAP"`.             |
| **B3** `absoluteRenderBounds`             | Skip             | Not consumed by deserializer. Computed by Figma.                           |
| **B4** Fill `visible`                     | Emit `true`      | All converter-produced fills are visible. ~1 line.                         |
| **B4** Fill `blendMode`, `boundVariables` | Strip            | Not consumed by deserializer. Strip from comparison.                       |
| **B5** Auto-layout x/y                    | Accept mismatch  | Figma overrides auto-layout positions. ABSOLUTE x/y already correct.       |
| **B6** Root dimensions                    | Accept mismatch  | Figma sections auto-resize. Improve height estimate.                       |

### Open Questions for Discussion

1. **B3 properties moving to Category A**: should `layoutPositioning`, `layoutGrow`, and `layoutAlign` be fixed as part of the Category A sprint, or separately?
2. **B2 defaults**: should the converter emit ALL Figma defaults (`visible`, `locked`, `blendMode`, `rotation: 0`, `opacity: 1`, `strokeWeight: 0`, etc.) to make the output more "Figma-like", or keep it minimal and only emit what the deserializer actually reads?
3. **Test comparison strategy**: should we build a `stripFigmaMetadata()` function that removes B1/B3.absoluteRenderBounds/B4.boundVariables/B5.autoLayoutXY from the expected file at test time? Or should we manually normalize the expected file once?

---

## Non-Figma-Source Research (2026-02-14)

### Structural Comparison: Figma-Exported vs Non-Figma Jay-HTML

Examined three real non-Figma-sourced jay-html files from `jay-framework/wix`:

- `examples/store/src/pages/cart/page.jay-html` (495 lines, ~335 lines of CSS)
- `examples/store/src/pages/categories/[slug]/page.jay-html` (367 lines, ~170 lines of CSS)
- `examples/whisky-store/src/pages/products/[slug]/page.jay-html` (459 lines, ~275 lines of CSS)

| Feature              | Figma-Exported Jay-HTML                         | Non-Figma Jay-HTML                                                                                                                    |
| -------------------- | ----------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| Styling mechanism    | Inline `style="..."` on every element           | CSS classes + `<style>` block + external stylesheets                                                                                  |
| HTML elements        | Almost all `<div>`                              | Semantic: `<header>`, `<nav>`, `<article>`, `<aside>`, `<h1>`-`<h2>`, `<p>`, `<a>`, `<button>`, `<input>`, `<select>`, `<ul>`, `<li>` |
| CSS units            | Only `px` and `%`                               | `px`, `%`, `rem`, `em`, `vw`, `vh`                                                                                                    |
| CSS variables        | None                                            | Extensive: `var(--bg-primary)`, `var(--border)`, `var(--radius-lg)`                                                                   |
| Layout               | Flexbox only (from Figma auto-layout)           | Flexbox + CSS Grid (`grid-template-columns`)                                                                                          |
| Figma metadata       | `data-figma-id`, `data-figma-type`, `data-name` | None                                                                                                                                  |
| External stylesheets | None                                            | `<link rel="stylesheet" href="../../styles/store-theme.css">` with 1300+ lines                                                        |
| CSS features         | Simple property:value pairs                     | Shorthands, inheritance, pseudo-classes, media queries, `@keyframes`, `calc()`                                                        |
| Colors               | `rgb()`, `rgba()`, hex                          | `rgb()`, hex, CSS variables, `hsl()`, named colors                                                                                    |

### Test Fixture: `non-figma-source-basic`

Created a minimal fixture using a simple header component with CSS classes and a `<style>` block (no external stylesheet dependency):

```
from-jay-html-fixtures/non-figma-source-basic/
├── input.jay-html     — <header> with <span> logo + <nav> with <a> links, styled via CSS classes
└── expected.figma.json — correct output IF CSS classes were resolved
```

**Result: TEST FAILS (as expected).** All structure and semantics are correct; all visual/layout properties from CSS classes are missing.

### Actual vs Expected Comparison

| Property                       | Expected (correct)                                       | Actual (current) | Root Cause                                                |
| ------------------------------ | -------------------------------------------------------- | ---------------- | --------------------------------------------------------- |
| header `layoutMode`            | `"HORIZONTAL"`                                           | _missing_        | `.header { display: flex }` not resolved                  |
| header `primaryAxisAlignItems` | `"SPACE_BETWEEN"`                                        | _missing_        | `.header { justify-content: space-between }` not resolved |
| header `counterAxisAlignItems` | `"CENTER"`                                               | _missing_        | `.header { align-items: center }` not resolved            |
| header `paddingTop/Bottom`     | `16`                                                     | _missing_        | `.header { padding-top: 16px }` not resolved              |
| header `paddingLeft/Right`     | `32`                                                     | _missing_        | `.header { padding-left: 32px }` not resolved             |
| header `fills`                 | `[{ type: "SOLID", color: { r: 0.2, g: 0.2, b: 0.2 } }]` | _missing_        | `.header { background-color: #333333 }` not resolved      |
| "Store" `fontSize`             | `24`                                                     | _missing_        | `.logo { font-size: 24px }` not resolved                  |
| "Store" `fontWeight`           | `700`                                                    | _missing_        | `.logo { font-weight: 700 }` not resolved                 |
| "Store" `fills`                | white text                                               | _missing_        | `.logo { color: #ffffff }` not resolved                   |
| nav `layoutMode`               | `"HORIZONTAL"`                                           | _missing_        | `.nav { display: flex }` not resolved                     |
| nav `itemSpacing`              | `24`                                                     | _missing_        | `.nav { gap: 24px }` not resolved                         |
| "Products"/"Cart" `fontSize`   | `14`                                                     | _missing_        | `.nav-link { font-size: 14px }` not resolved              |
| "Products"/"Cart" `fills`      | gray text                                                | _missing_        | `.nav-link { color: #999999 }` not resolved               |

**What IS correct in the actual output:**

- Tree structure: header FRAME → TEXT + nav FRAME → TEXT children ✓
- Semantic HTML: `semanticHtml: "header"`, `"nav"`, `"span"`, `"a"` ✓
- Text content extraction ✓
- Text defaults (textAlignVertical, letterSpacing, textCase, textTruncation, textAutoResize) ✓
- Node naming (from tag name or text content) ✓

### Key Finding: CSS Is Already Extracted by the Compiler

The `JayHtmlSourceFile` interface already provides:

- `css?: string` — All CSS from `<style>` blocks + read content of local linked stylesheets, concatenated
- `linkedCssFiles?: string[]` — Absolute paths to linked CSS files (for file watching)
- `headLinks: JayHtmlHeadLink[]` — Head link elements with href attributes

The compiler's `extractCss()` function in `jay-html-parser.ts`:

1. Reads inline `<style>` blocks via `root.querySelectorAll('head style, style')`
2. Resolves local `<link rel="stylesheet">` files via `path.resolve(filePath, href)` + `fs.readFile()`
3. Skips external URLs (`http://`, `https://`)
4. Joins all CSS parts with `\n\n`

**The CSS content is already available to the converter via `parsedJayHtml.css`. The converter simply doesn't use it.**

### Gap Inventory: Non-Figma-Sourced Files

#### N1. CSS Class Resolution (FUNDAMENTAL)

The converter only reads inline styles via `element.getAttribute('style')`. CSS rules from `<style>` blocks and linked stylesheets are completely ignored.

**Impact:** ALL visual and layout properties from CSS classes are lost. In the real-world files examined, 90%+ of styling comes from CSS classes. Without this, the converter produces structurally correct but completely unstyled Figma documents.

**The data is already available:** `parsedJayHtml.css` contains all the CSS text. The converter just needs to:

1. Parse CSS rules from the string
2. Match selectors to elements (class, tag, ID selectors)
3. Merge resolved properties with inline styles (inline takes precedence)
4. Feed merged styles through the existing `stylesToFigmaProps()`

**Approach options:**

- **Option A: Simple CSS parser (recommended for Phase 1)** — Parse `.class { prop: val }` rules, build a map from class name → properties. For each element, look up `class` attribute, merge all matching rules. This handles 80%+ of real-world non-Figma jay-html.
- **Option B: Full CSS engine** — Use a library like `css-tree` or `postcss` for full selector matching (combinators, pseudo-classes, specificity). More correct but heavier.
- **Option C: Headless browser `getComputedStyle()`** — Fully correct but loses layout intent (see below).

#### N2. CSS Variable Resolution

All three examined files use extensive CSS variables: `var(--bg-primary)`, `var(--border)`, `var(--radius-lg)`.

The store-theme.css defines 40+ variables in `:root {}`. These cascade through the entire page.

**Approach:** Parse the `:root {}` block from `parsedJayHtml.css`, build a variable map, and substitute `var(--name)` references with resolved values. Nested variables (`var(--a)` where `--a` itself uses `var(--b)`) need recursive resolution.

This is straightforward since CSS variables in `:root` are global constants (no cascade complexity).

#### N3. CSS Grid → Figma Auto-Layout

Real jay-html uses CSS grid extensively:

```css
.cart-layout {
  grid-template-columns: 1fr 380px;
  gap: 32px;
}
.product-grid {
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 24px;
}
.cart-item {
  grid-template-columns: 100px 1fr auto;
  gap: 24px;
}
```

Figma has no grid layout. Options:

- **Simple 2-column grid** (`1fr 380px`): Convert to HORIZONTAL auto-layout. First child gets `layoutSizingHorizontal: "FILL"`, second gets `width: 380`.
- **Auto-fill grid** (`repeat(auto-fill, minmax(280px, 1fr))`): Convert to HORIZONTAL auto-layout with `layoutWrap: "WRAP"`. Each child gets `minWidth: 280`, `layoutSizingHorizontal: "FILL"`.
- **Complex grid** (`100px 1fr auto`): Convert to HORIZONTAL auto-layout. Column widths map to child sizing.

This is lossy but provides a reasonable visual approximation. The key challenge is mapping `1fr` (fractional unit) to Figma's FILL/FIXED sizing model.

#### N4. CSS Shorthand Properties

Non-Figma CSS uses shorthands the converter doesn't handle:

- `padding: 16px 32px` (2-value: top/bottom, left/right)
- `padding: 12px 16px 12px 16px` (4-value)
- `margin: 0 auto` (centering)
- `border: 1px solid var(--border)` (shorthand with variable)
- `flex: 1` (shorthand for flex-grow/shrink/basis)
- `background: var(--bg-card)` (background shorthand)

**Approach:** Expand shorthands into longhand properties during the class resolution phase. CSS shorthand expansion is well-defined — `padding: a b` means `padding-top: a; padding-right: b; padding-bottom: a; padding-left: b`.

#### N5. CSS Inheritance

CSS properties like `color`, `font-family`, `font-size`, `line-height` are inherited from parent elements. The store-theme.css sets:

```css
body {
  font-family:
    'Outfit',
    system-ui,
    -apple-system,
    sans-serif;
  color: var(--text-primary);
  line-height: 1.6;
}
```

All text elements inherit this font and color unless overridden. The converter currently processes each element in isolation.

**Approach:** After resolving CSS classes, walk the tree top-down and propagate inheritable properties from parent to child (only for properties not explicitly set on the child). CSS defines a specific set of inheritable properties.

#### N6. Relative Units

Non-Figma CSS uses `rem`, `em` (from whisky-store: `font-size: 3rem`), percentage in non-width contexts. The converter only handles `px` and `%` (for width/height).

**Approach:** Assume `1rem = 16px` (browser default, can be configured), `1em = parent font size`. Convert at resolution time after inheritance is resolved.

#### N7. Margin → Figma Spacing

CSS `margin` has no direct Figma equivalent. In Figma auto-layout:

- `margin-bottom: 32px` between siblings → should increase parent's `itemSpacing`
- `margin: 0 auto` for centering → `layoutAlign: "CENTER"` or parent `counterAxisAlignItems: "CENTER"`

**Approach:** This is inherently lossy. For auto-layout children, margin can be partially mapped:

- Uniform margin between siblings → `itemSpacing` on parent (complex: different margins on different children)
- `margin: 0 auto` → centering alignment
- Margin on the outer-most element → padding on parent

#### N8. Interactive CSS (Pseudo-classes, Transitions, Animations)

`:hover`, `:focus`, `transition`, `@keyframes`, `cursor: pointer` — these have no visual representation in a static Figma document.

**Approach:** Skip these. They represent runtime behavior, not static visual state. A `cursor: pointer` might set `ref` metadata for interactivity, but that's a stretch.

#### N9. Media Queries

`@media (max-width: 1024px) { ... }` — responsive breakpoints.

**Approach:** Ignore media queries for now. The converter should use the "desktop" (default) styles. Future: could generate multiple Figma frames for different breakpoints.

#### N10. Form Elements

`<input>`, `<button>`, `<select>`, `<option>` — interactive HTML form elements with OS-default rendering.

**Approach:** Map to Figma FRAME approximations:

- `<button>` → FRAME with auto-layout containing a TEXT child (styled from CSS class)
- `<input>` → FRAME with a placeholder TEXT child
- `<select>` → FRAME with dropdown appearance

The `isTextElement()` function already handles `<span>`, `<p>`, `<a>`, `<label>`, `<h1>`-`<h6>`. Buttons and inputs are not text-like — they're containers with visual decoration.

#### N11. Named/HSL Colors

CSS color names (`red`, `blue`) and `hsl()`/`hsla()` are not parsed. Only `rgb()`, `rgba()`, hex.

**Approach:** Add an HSL-to-RGB converter and a named-color lookup table. Both are well-defined.

### Headless Browser Analysis

#### When it's valuable for non-Figma-sourced files

The headless browser approach is MORE valuable here than for roundtrip files because:

1. **CSS cascade resolution** — Classes + specificity + inheritance need a full engine
2. **CSS variables** — `var(--bg-primary)` needs `:root` context
3. **CSS grid** — `grid-template-columns` needs layout computation for child sizes
4. **Relative units** — `rem`, `em` need font-size context
5. **External stylesheets** — Full HTTP-resolved stylesheet loading

#### What it provides

```javascript
// For each element in the DOM:
const computed = window.getComputedStyle(element);
const bounds = element.getBoundingClientRect();

// Provides:
// - All resolved styles (colors as rgb(), sizes in px, variables resolved)
// - Exact pixel dimensions and positions
// - Inherited properties resolved
```

#### The critical trade-off: Loss of layout intent

From Design Log #90 (still applies, arguably more so):

| CSS (intent)                                      | Computed style                | Figma property needed                                           |
| ------------------------------------------------- | ----------------------------- | --------------------------------------------------------------- |
| `flex-grow: 1`                                    | `width: 347px`                | `layoutSizingHorizontal: 'FILL'`                                |
| `width: fit-content`                              | `width: 200px`                | `layoutSizingHorizontal: 'HUG'`                                 |
| `width: 100%`                                     | `width: 800px`                | `layoutSizingHorizontal: 'FILL'`                                |
| `display: grid; grid-template-columns: 1fr 380px` | children have computed widths | Need to infer grid structure                                    |
| `gap: 24px`                                       | children spaced 24px apart    | `itemSpacing: 24` (but only if we check declared, not computed) |

For layout properties, we need **declared CSS**, not computed styles. A headless browser gives us computed styles, which lose the information about whether an element should grow, hug, or be fixed.

#### Architecture considerations

The converter runs during `onImport` in `editor-handlers.ts`. Shelling out to a headless browser:

- **Latency:** 1-3 seconds per page (browser startup + render + DOM traversal)
- **Dependencies:** Playwright ~50MB, Puppeteer requires Chrome binary ~300MB
- **Deployment:** The `stack-cli` runs locally — browser engines are available on dev machines
- **Concurrency:** One browser instance can be reused for multiple pages

#### Recommended: Hybrid approach

**Phase 1 — CSS-in-converter (no browser):**

1. Parse CSS rules from `parsedJayHtml.css` using a lightweight parser
2. Resolve CSS variables from `:root {}` block
3. Match class selectors to elements, merge with inline styles
4. Expand shorthand properties
5. Resolve inheritance for inheritable properties
6. Feed merged styles through existing `stylesToFigmaProps()`

This handles ~80% of real-world non-Figma jay-html with zero new runtime dependencies.

**Phase 2 — Headless browser for dimensions only:**

1. Render the jay-html in Playwright (already a dev dependency for testing)
2. Extract `getBoundingClientRect()` for each element
3. Use computed dimensions for elements that can't be sized from CSS alone (grid children, auto-sized elements)
4. Do NOT use `getComputedStyle()` for layout properties — use declared CSS from Phase 1

This provides accurate dimensions without losing layout intent.

### Implementation Recommendation

**Start with Phase 1 (CSS-in-converter).** Here's why:

1. **The CSS is already available** — `parsedJayHtml.css` has all the text. No new data pipeline needed.
2. **The style-to-Figma mapping already works** — `stylesToFigmaProps()` and `stylesToTextProps()` handle all the CSS properties. We just need to feed them resolved styles from classes instead of only inline styles.
3. **High impact** — The test fixture shows that CSS class resolution alone would fix ALL 14 missing properties in the basic case.
4. **No new dependencies** — A simple CSS rule parser (regex or small library like `css-tree`) is sufficient.
5. **Preserves layout intent** — Declared CSS values tell us `display: flex` and `gap: 24px`, which map cleanly to Figma auto-layout.

**Suggested implementation order:**

1. Parse CSS rules from `parsedJayHtml.css` → build selector→properties map
2. Add CSS variable resolution (`:root {}` variables)
3. Match class/tag selectors to elements, merge with inline styles
4. Expand common shorthands (padding, margin, border, flex, background)
5. Add CSS inheritance propagation
6. Map CSS grid to auto-layout approximation
7. (Phase 2) Add headless browser for computed dimensions

### Open Questions for Discussion

1. **CSS parser choice:** Should we use a lightweight regex-based parser (handles `.class { }` rules), or a proper CSS library like `css-tree` or `postcss`? The regex approach is simpler but won't handle complex selectors.
2. **Specificity:** Should we implement full CSS specificity rules, or just use a simpler precedence model (inline > class > tag)?
3. **Scope of Phase 1:** Should we handle just class selectors (`.foo { }`) and tag selectors (`header { }`), or also combinators (`.foo .bar { }`, `.foo > .bar { }`)?
4. **CSS grid strategy:** Should we attempt grid-to-auto-layout conversion in Phase 1, or defer to Phase 2 (headless browser)?
5. **Form elements:** Should `<button>`, `<input>`, `<select>` be handled as containers (FRAME) or treated specially?

---

## Implementation Results: Category A Gap Fixes (2026-02-14)

### Summary

Fixed 4 of 6 Category A gaps via TDD. Created 4 new test fixtures and updated all existing fixtures. Each gap was fixed with: create fixture with correct expected (RED) → fix converter → run tests (GREEN) → verify no regressions.

### Test Suite Status After Fixes

| Test                        | Status | Description                                                         |
| --------------------------- | ------ | ------------------------------------------------------------------- |
| hello-world                 | GREEN  | Basic text + frame                                                  |
| background-fills            | GREEN  | Solid colors, gradients                                             |
| strokes-borders             | GREEN  | Border colors/widths + strokeAlign + per-side weights               |
| effects                     | GREEN  | Shadows, blur                                                       |
| layout-sizing               | GREEN  | Flex sizing                                                         |
| overflow-clipping           | GREEN  | Overflow hidden/scroll                                              |
| border-radius               | GREEN  | Per-corner radius                                                   |
| font-style-mapping          | GREEN  | fontWeight -> fontName.style                                        |
| node-naming                 | GREEN  | data-name, data-figma-type naming                                   |
| node-naming-detailed        | GREEN  | **NEW** Full naming priority chain                                  |
| node-type-image             | GREEN  | img -> RECTANGLE with IMAGE fills                                   |
| node-type-vector            | GREEN  | data-figma-type=vector -> VECTOR with svgContent                    |
| text-nesting                | GREEN  | div>div(text) collapse to TEXT                                      |
| text-styles                 | GREEN  | fontSize, textAlign, letterSpacing, lineHeight                      |
| text-defaults               | GREEN  | **NEW** textAlignVertical, textCase, textTruncation, textAutoResize |
| min-max-dimensions          | GREEN  | min/max width/height                                                |
| component-set-enum          | GREEN  | if conditions -> COMPONENT_SET + COMPONENT + INSTANCE               |
| stroke-per-side             | GREEN  | **NEW** Per-side stroke weights + strokeAlign                       |
| layout-sizing-fixed-vs-fill | GREEN  | **NEW** FIXED vs FILL vs HUG distinction                            |
| non-figma-source-basic      | RED    | CSS class resolution (future — Prompt 3 research)                   |
| wix-store-product-page      | RED    | Full roundtrip integration test                                     |

**19 green, 2 red.** (was 15 green, 1 red before this work)

### Gap A1: Layout Sizing Values — FIXED

**Problem:** Nodes with explicit pixel dimensions (e.g., `width: 300px`) inside flex parents had no `layoutSizingHorizontal`/`layoutSizingVertical`. Figma needs `"FIXED"` for these.

**Fix:** After all FILL/HUG detection in `stylesToFigmaProps`, added:

```typescript
if (props.width !== undefined && !props.layoutSizingHorizontal) {
  props.layoutSizingHorizontal = 'FIXED';
}
if (props.height !== undefined && !props.layoutSizingVertical) {
  props.layoutSizingVertical = 'FIXED';
}
```

**Fixture:** `layout-sizing-fixed-vs-fill/` — tests FIXED (px), FILL (100%, flex-grow), HUG (fit-content) in a single flex container.

**Impact:** All fixture expected files updated to include FIXED sizing where applicable.

### Gap A2: Text Defaults — FIXED

**Problem:** TEXT nodes missing Figma defaults: `textAlignVertical`, `letterSpacing`, `textCase`, `textTruncation`, `textAutoResize`.

**Fix:** Added `buildTextDefaults()` helper and applied in both `convertTextElement()` and `tryCollapseTextWrapper()`:

- `textAlignVertical: "TOP"` — always
- `letterSpacing: { value: 0, unit: "PERCENT" }` — when not explicitly set
- `textCase: "ORIGINAL"` — when not set via CSS text-transform
- `textTruncation: "DISABLED"` — always
- `textAutoResize: "WIDTH_AND_HEIGHT"` — always

**Fixture:** `text-defaults/` — tests basic text, text with explicit letter-spacing, and collapsed text wrapper pattern.

### Gap A3: Per-Side Stroke Weights — FIXED

**Problem:** Converter only emitted `strokeWeight` (uniform). Multi-value `border-width: T R B L` was parsed to max weight but individual sides lost.

**Fix:** Updated `stylesToFigmaProps` border-width parsing to emit `strokeTopWeight`, `strokeRightWeight`, `strokeBottomWeight`, `strokeLeftWeight` alongside `strokeWeight`. Both shorthand `border: 2px solid ...` and separate `border-width: T R B L` patterns handled.

**Fixture:** `stroke-per-side/` — tests uniform border, bottom-only, top-only, mixed per-side, and shorthand.

### Gap A5: Font Style Edge Case — ALREADY FIXED

Weight 800 + italic → "Extra Bold Italic" was already correctly handled by `fontWeightAndStyleToFigmaStyle`. The `font-style-mapping` fixture already covered this case and was GREEN.

### Gap A6: strokeAlign — FIXED

**Problem:** Converter didn't emit `strokeAlign`. CSS borders are always inside the box model.

**Fix:** Added to `stylesToFigmaProps`:

```typescript
if (props.strokes && props.strokes.length > 0) {
  props.strokeAlign = 'INSIDE';
}
```

And passed through in `convertFrameElement`.

Combined with A3 in the `stroke-per-side/` fixture.

### Gap A4: Node Naming — INVESTIGATED

**Finding:** The forward converter (`jay-desktop-poc/plugin/src/converters/`) does NOT emit `data-name` or `data-figma-id` attributes. It only uses `id` via `sanitizeHtmlId(name, id)`, which sanitizes and lowercases the name, making it non-recoverable.

**Reverse converter status:** The naming priority chain is correct:

1. `data-name` → exact name (highest priority)
2. `aria-label` → accessible label
3. `data-figma-type` → capitalized type name
4. HTML tag name → semantic name (header, nav, footer)
5. `rawTagName` → generic fallback (div)

**Action needed:** The forward converter (in `jay-desktop-poc`) should be updated to emit `data-name` and `data-figma-id` attributes to enable proper roundtrip naming. This is tracked as a separate task.

**Fixture:** `node-naming-detailed/` — validates the full naming priority chain with 7 test cases.

### Changes to `from-jay-html.ts`

| Change                                  | Lines affected | Description                                                                                           |
| --------------------------------------- | -------------- | ----------------------------------------------------------------------------------------------------- |
| `FigmaLayoutProps` interface            | +6 properties  | Added `strokeAlign`, `strokeTopWeight`, `strokeRightWeight`, `strokeBottomWeight`, `strokeLeftWeight` |
| `stylesToFigmaProps()` — border parsing | Updated        | Per-side stroke weights from multi-value `border-width`, `strokeAlign: "INSIDE"` when strokes present |
| `stylesToFigmaProps()` — sizing         | +6 lines       | FIXED sizing when explicit px dimensions and no FILL/HUG                                              |
| `buildTextDefaults()`                   | New function   | Emits Figma text defaults for TEXT nodes                                                              |
| `convertTextElement()`                  | +2 lines       | Applies `buildTextDefaults()`                                                                         |
| `tryCollapseTextWrapper()`              | +2 lines       | Applies `buildTextDefaults()`                                                                         |
| `convertFrameElement()`                 | +5 properties  | Passes through stroke-related properties                                                              |
