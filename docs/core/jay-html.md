# Jay-HTML Format

Jay-HTML is an extended HTML format that serves as the bridge between design tools and code. It defines both the UI design and the contract that components must implement.

A design tool may start by uploading a Jay Contract (`.jay-contract` file), or by creating a contract directly within the design tool. Once the design tool generates the `jay-html`, it contains all the contract information, and any original `.jay-contract` files are no longer required for the UI.

Jay-HTML is designed to allow the design tool to rewrite and update the file with no impact on the component code, as long as the contract remains unchanged. This enables seamless iteration on design without breaking the connection to the implementation.

## Overview

Jay-HTML files are **primarily intended to be generated by design tools** (such as Figma, Sketch, or other design systems). While they can be written manually, this is not the intended workflow of Jay. The framework is designed to solve the design-to-code challenge by enabling design tools to generate working code directly.

Jay-HTML files contain:

- **Data contracts** - Define the component's view state
- **UI structure** - HTML markup with extended syntax
- **Component imports** - References to other components
- **Template syntax** - Dynamic data binding and conditional rendering

## Design Tool Integration

The primary use case for Jay-HTML is integration with design tools:

1. **Designers create UI designs** in their preferred design tool.
2. **Designers connect the design to a Jay Contract** using plugins or built-in integrations.
3. **Design tools export Jay-HTML** using plugins or built-in exporters, embedding the contract and UI structure.
4. **Developers implement components** that satisfy the generated contracts, focusing on logic and state management.
5. **Applications use the components** with the generated UI, ensuring design and implementation remain in sync.

This workflow eliminates the manual translation of designs to code, allows fine-grained updates of design with no impact on the code as long as the contract does not change, and ensures that the implemented components match the design specifications exactly.

## Manual Authoring

While Jay-HTML can be written manually for prototyping or learning purposes, this approach:

- **Loses the design-to-code benefits** that Jay is designed to provide
- **Requires manual maintenance** of both design and code
- **May lead to inconsistencies** between design and implementation
- **Doesn't leverage Jay's core value proposition**

For production applications, it's recommended to use design tool integration rather than manual authoring.

## Basic Structure

A Jay-HTML file follows standard HTML structure with special script tags:

```html
<html>
  <head>
    <!-- Component imports -->
    <script type="application/jay-headfull" src="./item" names="Item"></script>

    <!-- Data and variants contract definition -->
    <script type="application/jay-data">
      data:
        count: number
        title: string
        items: array
    </script>
  </head>
  <body>
    <!-- UI structure with template syntax -->
    <div>
      <h1>{title}</h1>
      <span>{count}</span>
      <button ref="increment">+</button>
    </div>
  </body>
</html>
```

## Data Scripts

The `application/jay-data` script defines the component's view state contract.

### Basic Data Types

```html
<script type="application/jay-data">
  data:
    name: string
    age: number
    isActive: boolean
    score: number
</script>
```

### Complex Data Types

```html
<script type="application/jay-data">
  data:
    user:
      name: string
      email: string
      preferences:
        theme: string
        language: string
    items:
    - id: string
      title: string
      completed: boolean
    settings:
      notifications: boolean
      autoSave: boolean
</script>
```

### Enum Types

Enum types are are commonly used for variants, to capture which of a set of variations to render

```html
<script type="application/jay-data">
  data:
    status: enum (active | inactive | pending)
    priority: enum (low | medium | high | urgent)
    theme: enum (light | dark | auto)
</script>
```

### Array Types

```html
<script type="application/jay-data">
  data:
    todos:
    - id: string
      title: string
      completed: boolean
      priority: enum (low | medium | high)
    tags: array
    scores: number[]
</script>
```

## Component Imports

Jay-HTML files can import other components using special script tags.

### Importing Headfull Components

```html
<script type="application/jay-headfull" src="./item" names="Item"></script>
```

**Attributes**:

- `type="application/jay-headfull"` - Identifies this as a headfull component import
- `src="./item"` - Path to the component (without extension)
- `names="Item"` - Name of the component `const` to import, created using `makeJayComponent`
- `names="Item as AnotherName"` - Allows to rename the imported name to `AnotherName`

### Importing Headless Components

```html
<script
  type="application/jay-headless"
  contract="../named-counter/named-counter.jay-contract"
  src="../named-counter/named-counter"
  name="namedCounter"
  key="namedCounter"
></script>
```

**Attributes**:

- `type="application/jay-headless"` - Identifies this as a headless component import
- `contract` - Path to the contract file
- `src` - Path to the component implementation
- `name` - Name of the component `const` to import, created using `makeJayStackComponent`
- `key` - Attribute name under which the imported component's data and Refs are nested

## Head Links

Jay-HTML supports adding `<link>` elements to the document head for resources like stylesheets, icons, and other external resources. These links are automatically injected into the document head when the component is rendered.

### Basic Head Links

Add `<link>` elements directly in the `<head>` section:

```html
<html>
  <head>
    <link rel="stylesheet" href="styles/main.css" />
    <link rel="icon" href="/favicon.ico" />

    <script type="application/jay-data">
      data:
        title: string
    </script>
  </head>
  <body>
    <div>{title}</div>
  </body>
</html>
```

### Common Link Types

#### Stylesheets

```html
<head>
  <link rel="stylesheet" href="styles/main.css" />
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400&display=swap"
  />
</head>
```

#### Icons and Favicons

```html
<head>
  <link rel="icon" href="/favicon.ico" />
  <link rel="icon" type="image/png" href="/favicon.png" />
  <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
</head>
```

#### Preconnect and Preload

```html
<head>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="preload" href="critical.css" as="style" />
</head>
```

#### Web App Manifest

```html
<head>
  <link rel="manifest" href="/manifest.json" />
</head>
```

#### RSS Feeds

```html
<head>
  <link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/feed.xml" />
</head>
```

### Link Attributes

Head links support all standard HTML link attributes:

```html
<head>
  <!-- Basic attributes -->
  <link rel="stylesheet" href="styles/main.css" />

  <!-- With type attribute -->
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />

  <!-- With crossorigin -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

  <!-- With title -->
  <link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/feed.xml" />

  <!-- With media query -->
  <link rel="stylesheet" href="styles/mobile.css" media="(max-width: 768px)" />
</head>
```

### How It Works

When Jay-HTML files contain `<link>` elements in the `<head>` section:

1. **Parsing**: The compiler extracts all `<link>` elements from the head
2. **Code Generation**: The generated TypeScript code imports `injectHeadLinks` from `@jay-framework/runtime`
3. **Runtime Injection**: When the component renders, `injectHeadLinks` is called to inject the links into the document head
4. **Duplicate Prevention**: The runtime prevents duplicate links by checking both `href` and `rel` attributes

### Generated Code Example

For a Jay-HTML file with head links:

```html
<html>
  <head>
    <link rel="stylesheet" href="styles/main.css" />
    <link rel="icon" href="/favicon.ico" />

    <script type="application/jay-data">
      data:
        title: string
    </script>
  </head>
  <body>
    <div>{title}</div>
  </body>
</html>
```

The generated TypeScript will include:

```typescript
import { injectHeadLinks } from '@jay-framework/runtime';

// ... other imports and setup ...

injectHeadLinks([
  { rel: 'stylesheet', href: 'styles/main.css' },
  { rel: 'icon', href: '/favicon.ico' },
]);

// ... rest of component code ...
```

### Best Practices

#### 1. Use Relative Paths for Local Resources

```html
<!-- Good -->
<link rel="stylesheet" href="styles/main.css" />
<link rel="icon" href="/favicon.ico" />

<!-- Avoid absolute paths for local resources -->
<link rel="stylesheet" href="http://localhost:3000/styles/main.css" />
```

#### 2. Include Essential Resources

```html
<head>
  <!-- Critical stylesheet -->
  <link rel="stylesheet" href="styles/critical.css" />

  <!-- Favicon -->
  <link rel="icon" href="/favicon.ico" />

  <!-- Web app manifest for PWA -->
  <link rel="manifest" href="/manifest.json" />

  <!-- Preconnect to external domains -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
</head>
```

#### 3. Optimize Performance

```html
<head>
  <!-- Preconnect to external domains -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

  <!-- Preload critical resources -->
  <link rel="preload" href="fonts/inter.woff2" as="font" type="font/woff2" crossorigin />

  <!-- Load non-critical stylesheets -->
  <link rel="stylesheet" href="styles/non-critical.css" media="print" onload="this.media='all'" />
</head>
```

#### 4. Handle Special Characters

The compiler properly escapes special characters in URLs and attributes:

```html
<head>
  <!-- URLs with query parameters -->
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400&display=swap"
  />

  <!-- Titles with quotes -->
  <link rel="alternate" title='Site "Main" Page' href="/page with spaces.html" />
</head>
```

### Limitations

- **Import Links Excluded**: `<link rel="import">` elements are not injected as head links (they're handled separately for component imports)
- **Dynamic Links**: Head links are static and cannot be dynamically generated based on component state
- **Runtime Only**: Head links are only injected when the component is rendered in a browser environment

## CSS Support

Jay-HTML provides built-in CSS support that automatically extracts and bundles CSS from your components. This enables seamless integration with design tools while maintaining proper CSS organization.

### Overview

When a Jay-HTML file contains CSS (either via `<link>` tags or inline `<style>`), the compiler will:

1. **Extract CSS content** from `<link rel="stylesheet">` and `<style>` tags
2. **Generate a CSS file** with the same name as the Jay-HTML file (e.g., `counter.css` for `counter.jay-html`)
3. **Add a CSS import** to the generated TypeScript code
4. **Exclude CSS links** from head links injection (to prevent duplication)

### CSS Sources

Jay-HTML supports CSS from multiple sources:

#### External CSS Files

```html
<head>
  <link rel="stylesheet" href="styles/main.css" />
  <link rel="stylesheet" href="components/button.css" />
</head>
```

The compiler will:
- Read the CSS content from the referenced files
- Include the content in the generated CSS file
- Add comments indicating the source

#### Inline CSS

```html
<head>
  <style>
    .counter {
      color: blue;
      font-size: 18px;
    }
    
    .button {
      background: red;
      border: none;
      padding: 10px 20px;
    }
  </style>
</head>
```

#### Combined CSS

```html
<head>
  <link rel="stylesheet" href="styles/base.css" />
  <style>
    .component-specific {
      margin: 20px;
    }
  </style>
  <link rel="stylesheet" href="styles/theme.css" />
</head>
```

### Example

For a file `counter.jay-html` with CSS content:

**Input Jay-HTML:**
```html
<html>
  <head>
    <link rel="stylesheet" href="styles/main.css" />
    <style>
      .counter { color: blue; }
    </style>
    
    <script type="application/jay-data">
      data:
        count: number
    </script>
  </head>
  <body>
    <div class="counter">{count}</div>
  </body>
</html>
```

## Template Syntax

Jay-HTML extends HTML with template syntax for dynamic content.

### Data Binding

Use `{expression}` to display data:

```html
<div>
  <h1>{title}</h1>
  <p>Count: {count}</p>
  <span>Status: {user.status}</span>
</div>
```

### Conditional Rendering

Use `if="condition"` for conditional elements:

```html
<div>
  <h1>{title}</h1>

  <!-- Simple condition -->
  <p if="isVisible">This is visible</p>

  <!-- Complex condition -->
  <div if="user.isLoggedIn && user.hasPermission">
    <button>Admin Action</button>
  </div>

  <!-- Multiple conditions -->
  <div if="status == active">Active</div>
  <div if="status == inactive">Inactive</div>
  <div if="status == pending">Pending</div>
</div>
```

### List Rendering

Use `forEach="array"` and `trackBy="key"` for list rendering:

```html
<ul>
  <li forEach="todos" trackBy="id">
    <span>{title}</span>
    <button if="!completed">Complete</button>
  </li>
</ul>
```

### Component Rendering

Render imported components:

```html
<div>
  <!-- Simple component -->
  <button text="Click me" />

  <!-- Component with props -->
  <Item title="{item.title}" completed="{item.completed}" forEach="items" trackBy="id" />

  <!-- Headless component -->
  <div>
    <span>Count: {namedCounter.count}</span>
    <button ref="namedCounter.increment">+</button>
  </div>
</div>
```

## References

Use `ref="name"` to create named references for component interaction:

```html
<div>
  <input ref="username" value="{user.name}" />
  <button ref="submit">Submit</button>
  <div ref="message">{message}</div>
</div>
```

### References for Imported Headless Components

For a headless component imported with a certain key, references are prefixed with that key.

```html
<div>
  <form>
    <input ref="form.username" />
    <input ref="form.password" />
    <button ref="form.submit">Login</button>
  </form>

  <div>
    <button ref="modal.close">Close</button>
    <div ref="modal.content">{modalContent}</div>
  </div>
</div>
```

## Best Practices

### 1. Structure Your Data

Organize data logically:

```html
<script type="application/jay-data">
  data:
    # User information
    user:
      name: string
      email: string
      avatar: string

    # Application state
    state:
      isLoading: boolean
      error: string
      currentView: enum (list | detail | edit)

    # Data collections
    items:
    - id: string
      title: string
      description: string
      createdAt: string
</script>
```

### 2. Use Descriptive References

Choose meaningful reference names:

```html
<!-- Good -->
<button ref="submitButton">Submit</button>
<input ref="emailInput" />
<div ref="errorMessage">{error}</div>

<!-- Avoid -->
<button ref="btn">Submit</button>
<input ref="input1" />
<div ref="msg">{error}</div>
```

### 3. Keep Templates Readable

Use proper indentation and structure:

```html
<div class="user-profile">
  <header class="profile-header">
    <img src="{user.avatar}" alt="Avatar" class="avatar" />
    <h1 class="name">{user.name}</h1>
    <p class="email">{user.email}</p>
  </header>

  <section class="profile-content" if="!state.isLoading">
    <div class="stats">
      <div class="stat">
        <span class="label">Posts</span>
        <span class="value">{user.postCount}</span>
      </div>
    </div>
  </section>
</div>
```

## Type Generation

Jay automatically generates TypeScript types from Jay-HTML files:

```typescript
// Generated from todo.jay-html
export enum FilterOfTodoViewState {
  all,
  active,
  completed,
}

export interface ShownTodoOfTodoViewState {
  id: string;
  title: string;
  isCompleted: boolean;
}

export interface TodoViewState {
  activeTodoCount: number;
  activeTodoWord: string;
  hasItems: boolean;
  noActiveItems: boolean;
  filter: FilterOfTodoViewState;
  showClearCompleted: boolean;
  newTodo: string;
  shownTodos: Array<ShownTodoOfTodoViewState>;
}

export type ItemRef<ParentVS> = MapEventEmitterViewState<ParentVS, ReturnType<typeof Item>>;
export type ItemRefs<ParentVS> = ComponentCollectionProxy<ParentVS, ItemRef<ParentVS>> &
  OnlyEventEmitters<ItemRef<ParentVS>>;

export interface TodoElementRefs {
  newTodo: HTMLElementProxy<TodoViewState, HTMLInputElement>;
  toggleAll: HTMLElementProxy<TodoViewState, HTMLInputElement>;
  filterAll: HTMLElementProxy<TodoViewState, HTMLAnchorElement>;
  filterActive: HTMLElementProxy<TodoViewState, HTMLAnchorElement>;
  filterCompleted: HTMLElementProxy<TodoViewState, HTMLAnchorElement>;
  clearCompleted: HTMLElementProxy<TodoViewState, HTMLButtonElement>;
  shownTodos: {
    items: ItemRefs<ShownTodoOfTodoViewState>;
  };
}
```

## Next Steps

Now that you understand Jay-HTML:

1. **Learn about Contract Files** - Create reusable component contracts
2. **Build Components** - Implement the logic for your Jay-HTML designs
3. **Explore Examples** - See real-world Jay-HTML patterns
4. **Master State Management** - Learn reactive state management

---

Ready to create your first component? Check out the [Component Development](./components.md) guide!
