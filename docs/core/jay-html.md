# Jay-HTML Format

Jay-HTML is an extended HTML format that serves as the bridge between design tools and code. It defines both the UI design and the contract that components must implement.

// review language
A Design tool may start by uploading a Jay Contract (`.jay-contract` file), or by creating a contract
directly at the design tool. Once the design tool creates the `jay-html` it contains the contract information
and any original `.jay-contract` files are not required anymore.

`jay-html` is designed to allow the design tool to rewrite and update the file with no impact 
on the component code.

## Overview

Jay-HTML files are **primarily intended to be generated by design tools** (such as Figma, Sketch, or other design systems). While they can be written manually, this is not the intended workflow of Jay. The framework is designed to solve the design-to-code challenge by enabling design tools to generate working code directly.

Jay-HTML files contain:

- **Data contracts** - Define the component's view state
- **UI structure** - HTML markup with extended syntax
- **Component imports** - References to other components
- **Template syntax** - Dynamic data binding and conditional rendering

## Design Tool Integration

The primary use case for Jay-HTML is integration with design tools:

1. **Designers create UI designs** in their preferred design tool
2. **Designers connect the design to Jay Contract** using plugins 
2. **Design tools export Jay-HTML** using plugins or built-in exporters
3. **Developers implement components** that satisfy the generated contracts
4. **Applications use the components** with the generated UI

// todo review language
This workflow eliminates the manual translation of designs to code,
allows fine grained updates of design with no impact on the code as long as the contract does not change 
and ensures that the implemented components match the design specifications exactly.

## Manual Authoring

While Jay-HTML can be written manually for prototyping or learning purposes, this approach:
- **Loses the design-to-code benefits** that Jay is designed to provide
- **Requires manual maintenance** of both design and code
- **May lead to inconsistencies** between design and implementation
- **Doesn't leverage Jay's core value proposition**

For production applications, it's recommended to use design tool integration rather than manual authoring.

## Basic Structure

A Jay-HTML file follows standard HTML structure with special script tags:

```html
<html>
  <head>
    <!-- Component imports -->
    <script type="application/jay-headfull" src="./item" names="Item"></script>
    
    <!-- Data and variants contract definition -->
    <script type="application/jay-data">
      data:
        count: number
        title: string
        items: array
    </script>
  </head>
  <body>
    <!-- UI structure with template syntax -->
    <div>
      <h1>{title}</h1>
      <span>{count}</span>
      <button ref="increment">+</button>
    </div>
  </body>
</html>
```

## Data Scripts

The `application/jay-data` script defines the component's view state contract.

### Basic Data Types

```html
<script type="application/jay-data">
data:
  name: string
  age: number
  isActive: boolean
  score: number
</script>
```

### Complex Data Types

```html
<script type="application/jay-data">
data:
  user:
    name: string
    email: string
    preferences:
      theme: string
      language: string
  items:
  - id: string
    title: string
    completed: boolean
  settings:
    notifications: boolean
    autoSave: boolean
</script>
```

### Enum Types

Enum types are are commonly used for variants, to capture which of a set of variations to render 

```html
<script type="application/jay-data">
data:
  status: enum (active | inactive | pending)
  priority: enum (low | medium | high | urgent)
  theme: enum (light | dark | auto)
</script>
```

### Array Types

```html
<script type="application/jay-data">
data:
  todos:
  - id: string
    title: string
    completed: boolean
    priority: enum (low | medium | high)
  tags: array
  scores: number[]
</script>
```

## Component Imports

Jay-HTML files can import other components using special script tags.

### Importing Headfull Components

```html
<script type="application/jay-headfull" src="./item" names="Item"></script>
```

**Attributes**:
- `type="application/jay-headfull"` - Identifies this as a headfull component import
- `src="./item"` - Path to the component (without extension)
- `names="Item"` - Name of the component `const` to import, created using `makeJayComponent`
- `names="Item as AnotherName"` - Allows to rename the imported name to `AnotherName`

### Importing Headless Components

```html
<script
  type="application/jay-headless"
  contract="../named-counter/named-counter.jay-contract"
  src="../named-counter/named-counter"
  name="namedCounter"
  key="namedCounter"
></script>
```

**Attributes**:
- `type="application/jay-headless"` - Identifies this as a headless component import
- `contract` - Path to the contract file
- `src` - Path to the component implementation
- `name` - Name of the component `const` to import, created using `makeJayStackComponent`
- `key` - Attribute name under which the imported component's data and Refs are nested

## Template Syntax

Jay-HTML extends HTML with template syntax for dynamic content.

### Data Binding

Use `{expression}` to display data:

```html
<div>
  <h1>{title}</h1>
  <p>Count: {count}</p>
  <span>Status: {user.status}</span>
</div>
```

### Conditional Rendering

Use `if="condition"` for conditional elements:

```html
<div>
  <h1>{title}</h1>
  
  <!-- Simple condition -->
  <p if="isVisible">This is visible</p>
  
  <!-- Complex condition -->
  <div if="user.isLoggedIn && user.hasPermission">
    <button>Admin Action</button>
  </div>
  
  <!-- Multiple conditions -->
  <div if="status == active">Active</div>
  <div if="status == inactive">Inactive</div>
  <div if="status == pending">Pending</div>
</div>
```

### List Rendering

Use `forEach="array"` and `trackBy="key"` for list rendering:

```html
<ul>
  <li forEach="todos" trackBy="id">
    <span>{title}</span>
    <button if="!completed">Complete</button>
  </li>
</ul>
```

### Component Rendering

Render imported components:

```html
<div>
  <!-- Simple component -->
  <Button text="Click me" />
  
  <!-- Component with props -->
  <Item 
    title="{item.title}" 
    completed={item.completed} 
    forEach="items" 
    trackBy="id" 
  />
  
  <!-- Headless component -->
  <div>
    <span>Count: {namedCounter.count}</span>
    <button ref="namedCounter.increment">+</button>
  </div>
</div>
```

## References

Use `ref="name"` to create named references for component interaction:

```html
<div>
  <input ref="username" value="{user.name}" />
  <button ref="submit">Submit</button>
  <div ref="message">{message}</div>
</div>
```

### References for Imported Headless Components

For a headless component imported with a certain key, references are prefixed with that key. 

```html
<div>
  <form >
    <input ref="form.username" />
    <input ref="form.password" />
    <button ref="form.submit">Login</button>
  </form>
  
  <div >
    <button ref="modal.close">Close</button>
    <div ref="modal.content">{modalContent}</div>
  </div>
</div>
```

## Best Practices

### 1. Structure Your Data

Organize data logically:

```html
<script type="application/jay-data">
data:
  # User information
  user:
    name: string
    email: string
    avatar: string
  
  # Application state
  state:
    isLoading: boolean
    error: string
    currentView: enum (list | detail | edit)
  
  # Data collections
  items:
  - id: string
    title: string
    description: string
    createdAt: string
</script>
```

### 2. Use Descriptive References

Choose meaningful reference names:

```html
<!-- Good -->
<button ref="submitButton">Submit</button>
<input ref="emailInput" />
<div ref="errorMessage">{error}</div>

<!-- Avoid -->
<button ref="btn">Submit</button>
<input ref="input1" />
<div ref="msg">{error}</div>
```

### 3. Keep Templates Readable

Use proper indentation and structure:

```html
<div class="user-profile">
  <header class="profile-header">
    <img src="{user.avatar}" alt="Avatar" class="avatar" />
    <h1 class="name">{user.name}</h1>
    <p class="email">{user.email}</p>
  </header>
  
  <section class="profile-content" if="!state.isLoading">
    <div class="stats">
      <div class="stat">
        <span class="label">Posts</span>
        <span class="value">{user.postCount}</span>
      </div>
    </div>
  </section>
</div>
```

## Type Generation

Jay automatically generates TypeScript types from Jay-HTML files:

```typescript
// Generated from todo.jay-html
export enum FilterOfTodoViewState {
    all,
    active,
    completed
}

export interface ShownTodoOfTodoViewState {
    id: string,
    title: string,
    isCompleted: boolean
}

export interface TodoViewState {
    activeTodoCount: number,
    activeTodoWord: string,
    hasItems: boolean,
    noActiveItems: boolean,
    filter: FilterOfTodoViewState,
    showClearCompleted: boolean,
    newTodo: string,
    shownTodos: Array<ShownTodoOfTodoViewState>
}

export type ItemRef<ParentVS> = MapEventEmitterViewState<ParentVS, ReturnType<typeof Item>>;
export type ItemRefs<ParentVS> =
    ComponentCollectionProxy<ParentVS, ItemRef<ParentVS>> &
    OnlyEventEmitters<ItemRef<ParentVS>>

export interface TodoElementRefs {
    newTodo: HTMLElementProxy<TodoViewState, HTMLInputElement>,
    toggleAll: HTMLElementProxy<TodoViewState, HTMLInputElement>,
    filterAll: HTMLElementProxy<TodoViewState, HTMLAnchorElement>,
    filterActive: HTMLElementProxy<TodoViewState, HTMLAnchorElement>,
    filterCompleted: HTMLElementProxy<TodoViewState, HTMLAnchorElement>,
    clearCompleted: HTMLElementProxy<TodoViewState, HTMLButtonElement>,
    shownTodos: {
        items: ItemRefs<ShownTodoOfTodoViewState>
    }
}
```

## Next Steps

Now that you understand Jay-HTML:

1. **Learn about Contract Files** - Create reusable component contracts
2. **Build Components** - Implement the logic for your Jay-HTML designs
3. **Explore Examples** - See real-world Jay-HTML patterns
4. **Master State Management** - Learn reactive state management

---

Ready to create your first component? Check out the [Component Development](./components.md) guide!