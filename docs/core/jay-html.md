# Jay-HTML Format

Jay-HTML is an extended HTML format that serves as the bridge between design tools and code. It defines both the UI design and the contract that components must implement.

A design tool may start by uploading a Jay Contract (`.jay-contract` file), or by creating a contract directly within the design tool. Once the design tool generates the `jay-html`, it contains all the contract information, and any original `.jay-contract` files are no longer required for the UI.

Jay-HTML is designed to allow the design tool to rewrite and update the file with no impact on the component code, as long as the contract remains unchanged. This enables seamless iteration on design without breaking the connection to the implementation.

## Overview

Jay-HTML files are **primarily intended to be generated by design tools** (such as Figma, Sketch, or other design systems). While they can be written manually, this is not the intended workflow of Jay. The framework is designed to solve the design-to-code challenge by enabling design tools to generate working code directly.

Jay-HTML files contain:

- **Data contracts** - Define the component's view state
- **UI structure** - HTML markup with extended syntax
- **Component imports** - References to other components
- **Template syntax** - Dynamic data binding and conditional rendering

## Design Tool Integration

The primary use case for Jay-HTML is integration with design tools:

1. **Designers create UI designs** in their preferred design tool.
2. **Designers connect the design to a Jay Contract** using plugins or built-in integrations.
3. **Design tools export Jay-HTML** using plugins or built-in exporters, embedding the contract and UI structure.
4. **Developers implement components** that satisfy the generated contracts, focusing on logic and state management.
5. **Applications use the components** with the generated UI, ensuring design and implementation remain in sync.

This workflow eliminates the manual translation of designs to code, allows fine-grained updates of design with no impact on the code as long as the contract does not change, and ensures that the implemented components match the design specifications exactly.

## Manual Authoring

While Jay-HTML can be written manually for prototyping or learning purposes, this approach:

- **Loses the design-to-code benefits** that Jay is designed to provide
- **Requires manual maintenance** of both design and code
- **May lead to inconsistencies** between design and implementation
- **Doesn't leverage Jay's core value proposition**

For production applications, it's recommended to use design tool integration rather than manual authoring.

## Basic Structure

A Jay-HTML file follows standard HTML structure with special script tags:

```html
<html>
  <head>
    <!-- Component imports -->
    <script type="application/jay-headfull" src="./item" names="Item"></script>

    <!-- Data and variants contract definition -->
    <script type="application/jay-data">
      data:
        count: number
        title: string
        items: array
    </script>
  </head>
  <body>
    <!-- UI structure with template syntax -->
    <div>
      <h1>{title}</h1>
      <span>{count}</span>
      <button ref="increment">+</button>
    </div>
  </body>
</html>
```

## Data Scripts

The `application/jay-data` script defines the component's view state contract.

### Basic Data Types

```html
<script type="application/jay-data">
  data:
    name: string
    age: number
    isActive: boolean
    score: number
</script>
```

### Complex Data Types

```html
<script type="application/jay-data">
  data:
    user:
      name: string
      email: string
      preferences:
        theme: string
        language: string
    items:
    - id: string
      title: string
      completed: boolean
    settings:
      notifications: boolean
      autoSave: boolean
</script>
```

### Enum Types

Enum types are are commonly used for variants, to capture which of a set of variations to render

```html
<script type="application/jay-data">
  data:
    status: enum (active | inactive | pending)
    priority: enum (low | medium | high | urgent)
    theme: enum (light | dark | auto)
</script>
```

### Array Types

```html
<script type="application/jay-data">
  data:
    todos:
    - id: string
      title: string
      completed: boolean
      priority: enum (low | medium | high)
    tags: array
    scores: number[]
</script>
```

## Component Imports

Jay-HTML files can import other components using special script tags.

### Importing Headfull Components

```html
<script type="application/jay-headfull" src="./item" names="Item"></script>
```

**Attributes**:

- `type="application/jay-headfull"` - Identifies this as a headfull component import
- `src="./item"` - Path to the component (without extension)
- `names="Item"` - Name of the component `const` to import, created using `makeJayComponent`
- `names="Item as AnotherName"` - Allows to rename the imported name to `AnotherName`

### Importing Headless Components

```html
<script
  type="application/jay-headless"
  contract="../named-counter/named-counter.jay-contract"
  src="../named-counter/named-counter"
  name="namedCounter"
  key="namedCounter"
></script>
```

**Attributes**:

- `type="application/jay-headless"` - Identifies this as a headless component import
- `contract` - Path to the contract file
- `src` - Path to the component implementation
- `name` - Name of the component `const` to import, created using `makeJayStackComponent`
- `key` - Attribute name under which the imported component's data and Refs are nested

## Head Links

Jay-HTML supports adding `<link>` elements to the document head for resources like stylesheets, icons, and other external resources. These links are automatically injected into the document head when the component is rendered.

### Basic Head Links

Add `<link>` elements directly in the `<head>` section:

```html
<html>
  <head>
    <link rel="stylesheet" href="styles/main.css" />
    <link rel="icon" href="/favicon.ico" />

    <script type="application/jay-data">
      data:
        title: string
    </script>
  </head>
  <body>
    <div>{title}</div>
  </body>
</html>
```

### Common Link Types

#### Stylesheets

```html
<head>
  <link rel="stylesheet" href="styles/main.css" />
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400&display=swap"
  />
</head>
```

#### Icons and Favicons

```html
<head>
  <link rel="icon" href="/favicon.ico" />
  <link rel="icon" type="image/png" href="/favicon.png" />
  <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
</head>
```

#### Preconnect and Preload

```html
<head>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="preload" href="critical.css" as="style" />
</head>
```

#### Web App Manifest

```html
<head>
  <link rel="manifest" href="/manifest.json" />
</head>
```

#### RSS Feeds

```html
<head>
  <link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/feed.xml" />
</head>
```

### Link Attributes

Head links support all standard HTML link attributes:

```html
<head>
  <!-- Basic attributes -->
  <link rel="stylesheet" href="styles/main.css" />

  <!-- With type attribute -->
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />

  <!-- With crossorigin -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

  <!-- With title -->
  <link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/feed.xml" />

  <!-- With media query -->
  <link rel="stylesheet" href="styles/mobile.css" media="(max-width: 768px)" />
</head>
```

### How It Works

When Jay-HTML files contain `<link>` elements in the `<head>` section:

1. **Parsing**: The compiler extracts all `<link>` elements from the head
2. **Code Generation**: The generated TypeScript code imports `injectHeadLinks` from `@jay-framework/runtime`
3. **Runtime Injection**: When the component renders, `injectHeadLinks` is called to inject the links into the document head
4. **Duplicate Prevention**: The runtime prevents duplicate links by checking both `href` and `rel` attributes

### Generated Code Example

For a Jay-HTML file with head links:

```html
<html>
  <head>
    <link rel="stylesheet" href="styles/main.css" />
    <link rel="icon" href="/favicon.ico" />

    <script type="application/jay-data">
      data:
        title: string
    </script>
  </head>
  <body>
    <div>{title}</div>
  </body>
</html>
```

The generated TypeScript will include:

```typescript
import { injectHeadLinks } from '@jay-framework/runtime';

// ... other imports and setup ...

injectHeadLinks([
  { rel: 'stylesheet', href: 'styles/main.css' },
  { rel: 'icon', href: '/favicon.ico' },
]);

// ... rest of component code ...
```

### Best Practices

#### 1. Use Relative Paths for Local Resources

```html
<!-- Good -->
<link rel="stylesheet" href="styles/main.css" />
<link rel="icon" href="/favicon.ico" />

<!-- Avoid absolute paths for local resources -->
<link rel="stylesheet" href="http://localhost:3000/styles/main.css" />
```

#### 2. Include Essential Resources

```html
<head>
  <!-- Critical stylesheet -->
  <link rel="stylesheet" href="styles/critical.css" />

  <!-- Favicon -->
  <link rel="icon" href="/favicon.ico" />

  <!-- Web app manifest for PWA -->
  <link rel="manifest" href="/manifest.json" />

  <!-- Preconnect to external domains -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
</head>
```

#### 3. Optimize Performance

```html
<head>
  <!-- Preconnect to external domains -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

  <!-- Preload critical resources -->
  <link rel="preload" href="fonts/inter.woff2" as="font" type="font/woff2" crossorigin />

  <!-- Load non-critical stylesheets -->
  <link rel="stylesheet" href="styles/non-critical.css" media="print" onload="this.media='all'" />
</head>
```

#### 4. Handle Special Characters

The compiler properly escapes special characters in URLs and attributes:

```html
<head>
  <!-- URLs with query parameters -->
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400&display=swap"
  />

  <!-- Titles with quotes -->
  <link rel="alternate" title='Site "Main" Page' href="/page with spaces.html" />
</head>
```

### Limitations

- **Import Links Excluded**: `<link rel="import">` elements are not injected as head links (they're handled separately for component imports)
- **Dynamic Links**: Head links are static and cannot be dynamically generated based on component state
- **Runtime Only**: Head links are only injected when the component is rendered in a browser environment

## CSS Support

Jay-HTML provides built-in CSS support that automatically extracts and bundles CSS from your components. This enables seamless integration with design tools while maintaining proper CSS organization.

### Overview

When a Jay-HTML file contains CSS (either via `<link>` tags or inline `<style>`), the compiler will:

1. **Extract CSS content** from `<link rel="stylesheet">` and `<style>` tags
2. **Generate a CSS file** with the same name as the Jay-HTML file (e.g., `counter.css` for `counter.jay-html`)
3. **Add a CSS import** to the generated TypeScript code
4. **Exclude CSS links** from head links injection (to prevent duplication)

### CSS Sources

Jay-HTML supports CSS from multiple sources:

#### External CSS Files

```html
<head>
  <link rel="stylesheet" href="styles/main.css" />
  <link rel="stylesheet" href="components/button.css" />
</head>
```

The compiler will:

- Read the CSS content from the referenced files
- Include the content in the generated CSS file
- Add comments indicating the source

#### Inline CSS

```html
<head>
  <style>
    .counter {
      color: blue;
      font-size: 18px;
    }

    .button {
      background: red;
      border: none;
      padding: 10px 20px;
    }
  </style>
</head>
```

#### Combined CSS

```html
<head>
  <link rel="stylesheet" href="styles/base.css" />
  <style>
    .component-specific {
      margin: 20px;
    }
  </style>
  <link rel="stylesheet" href="styles/theme.css" />
</head>
```

### Example

For a file `counter.jay-html` with CSS content:

**Input Jay-HTML:**

```html
<html>
  <head>
    <link rel="stylesheet" href="styles/main.css" />
    <style>
      .counter {
        color: blue;
      }
    </style>

    <script type="application/jay-data">
      data:
        count: number
    </script>
  </head>
  <body>
    <div class="counter">{count}</div>
  </body>
</html>
```

## Template Syntax

Jay-HTML extends HTML with template syntax for dynamic content.

### Data Binding

Use `{expression}` to display data:

```html
<div>
  <h1>{title}</h1>
  <p>Count: {count}</p>
  <span>Status: {user.status}</span>
</div>
```

### Class Binding

Jay-HTML supports dynamic class binding with conditional expressions:

#### Static Classes with Dynamic Additions

```html
<div class="button {variant}">Click me</div>
```

#### Conditional Classes

Use the `{condition ? class-name}` syntax to conditionally add a class:

```html
<div class="cart-indicator {hasItems ? has-items} {isLoading ? is-loading}">
  Cart
</div>
```

When the condition is true, the class is added. When false, it's omitted. Note that the class name is **not quoted** in this syntax.

#### Full Ternary for Class Switching

Use the full ternary syntax `{condition ? class-a : class-b}` to switch between two classes:

```html
<div class="button {isPrimary ? primary : secondary}">
  Click me
</div>
```

#### Combining Multiple Conditional Classes

You can combine static classes with multiple conditional classes:

```html
<a href="/cart" 
   class="cart-indicator {hasItems ? has-items} {isLoading ? is-loading} {justAdded ? just-added}">
  <span class="icon">ðŸ›’</span>
  <span class="count" if="hasItems">{itemCount}</span>
</a>
```

### Conditional Rendering

Use `if="condition"` for conditional elements:

```html
<div>
  <h1>{title}</h1>

  <!-- Simple condition -->
  <p if="isVisible">This is visible</p>

  <!-- Complex condition -->
  <div if="user.isLoggedIn && user.hasPermission">
    <button>Admin Action</button>
  </div>

  <!-- Multiple conditions -->
  <div if="status == active">Active</div>
  <div if="status == inactive">Inactive</div>
  <div if="status == pending">Pending</div>
</div>
```

### List Rendering

Use `forEach="array"` and `trackBy="key"` for list rendering:

```html
<ul>
  <li forEach="todos" trackBy="id">
    <span>{title}</span>
    <button if="!completed">Complete</button>
  </li>
</ul>
```

### Recursive Structures

Jay-HTML supports recursive rendering within a single HTML structure and a single Jay Component, allowing you to build complex nested UIs like trees, nested comments, file browsers, and more without extracting separate components.

#### Marking Recursive Regions

Use the `ref` attribute to mark a region that can be recursively rendered:

```html
<div ref="treeNode">
  <div class="node-name">{name}</div>
  <!-- Recursive content goes here -->
</div>
```

#### Recursive Data Types

Define recursive data structures using JSON Schema-style references with the `$` prefix:

```html
<script type="application/jay-data">
  data:
    name: string
    id: string
    children: array<$/data>  # Recursive reference to root type
</script>
```

For single optional children (linked lists, binary trees):

```html
<script type="application/jay-data">
  data:
    value: number
    id: string
    left: $/data   # References root type (nullable)
    right: $/data  # References root type (nullable)
</script>
```

For nested recursive structures, use path syntax to reference nested types:

```html
<script type="application/jay-data">
  data:
    title: string
    tree:
      id: string
      name: string
      children: $/data/tree  # References the tree type nested in data
</script>
```

The `$/data/path` syntax allows you to reference any nested type in your data structure for recursion.

#### Array-Based Recursion (forEach)

For homogeneous tree structures where all children share the same structure:

```html
<div ref="treeNode">
  <div class="tree-head">
    <span class="tree-arrow" if="hasChildren && open">â–¼</span>
    <span class="tree-arrow" if="hasChildren && !open">â–º</span>
    <span class="tree-name">{name}</span>
  </div>

  <!-- Recurse through children array -->
  <ul if="open" class="tree-children">
    <li forEach="children" trackBy="id">
      <recurse ref="treeNode" />
    </li>
  </ul>
</div>
```

**Data Contract:**

```html
<script type="application/jay-data">
  data:
    name: string
    id: string
    open: boolean
    hasChildren: boolean
    children: array<$/data>
</script>
```

**Key Points:**

- The `<recurse ref="treeNode">` element triggers recursion for each child
- `forEach` provides both iteration context and recursion guard (stops when array is empty)
- Use `trackBy` for efficient DOM updates
- The recursion naturally terminates when reaching leaf nodes (empty `children` array)

#### Accessor-Based Recursion

For heterogeneous structures where different paths lead to children (binary trees, linked lists):

```html
<div ref="btreeNode">
  <div class="node-value">{value}</div>
  <div class="children">
    <!-- Left child -->
    <div class="left-child" if="hasLeft">
      <div class="branch">L</div>
      <recurse ref="btreeNode" accessor="left" />
    </div>

    <!-- Right child -->
    <div class="right-child" if="hasRight">
      <div class="branch">R</div>
      <recurse ref="btreeNode" accessor="right" />
    </div>
  </div>
</div>
```

**Data Contract:**

```html
<script type="application/jay-data">
  data:
    value: number
    id: string
    hasLeft: boolean
    hasRight: boolean
    left: $/data
    right: $/data
</script>
```

**Key Points:**

- The `accessor` attribute specifies which property to follow for recursion
- Each accessor uses `withData` runtime function which includes built-in null checking
- Recursion is self-guarding - automatically stops when accessor returns `null`
- The `if` conditions are optional for safety (built into `withData`) but useful for UX

#### Context Switching with `<with-data>`

When recursive data is nested within a parent structure (e.g., `data.tree` instead of just `data`), use `<with-data>` to switch the view state context before entering the recursive region:

```html
<html>
  <head>
    <script type="application/jay-data">
      data:
        title: string
        description: string
        btree:
          value: number
          id: string
          hasLeft: boolean
          hasRight: boolean
          left: $/data/btree
          right: $/data/btree
    </script>
  </head>
  <body>
    <div class="tree-container">
      <h1>{title}</h1>
      <p>{description}</p>

      <!-- Switch context to btree for recursive region -->
      <with-data accessor="btree">
        <div class="tree-node" ref="treeNode">
          <div class="node-value">{value}</div>
          <div class="children">
            <div class="left-child" if="hasLeft">
              <recurse ref="treeNode" accessor="left" />
            </div>
            <div class="right-child" if="hasRight">
              <recurse ref="treeNode" accessor="right" />
            </div>
          </div>
        </div>
      </with-data>
    </div>
  </body>
</html>
```

**Key Points:**

- `<with-data accessor="property">` switches the view state context to the specified property
- Inside `<with-data>`, properties are accessed relative to the new context
- The recursive region operates on a consistent type whether called initially or recursively
- `<with-data>` must have exactly one child element
- Works with both object and array types

**Identity Accessor with forEach:**

When `<with-data>` narrows context to an array, use `forEach="."` to iterate over it:

```html
<with-data accessor="tree">
  <ul ref="menuItem">
    <li forEach="." trackBy="id">
      <span>{name}</span>
      <div if="children">
        <recurse ref="menuItem" accessor="children" />
      </div>
    </li>
  </ul>
</with-data>
```

The `forEach="."` syntax means "iterate over the current context", which is useful after `<with-data>` has already narrowed to an array.

#### Linked List Example

```html
<div ref="listNode">
  <div class="item-value">{value}</div>

  <!-- Recurse to next item if it exists -->
  <div class="next-item" if="hasNext">
    <div class="arrow">â†’</div>
    <recurse ref="listNode" accessor="next" />
  </div>
</div>
```

**Data Contract:**

```html
<script type="application/jay-data">
  data:
    value: string
    id: string
    hasNext: boolean
    next: $/data
</script>
```

#### How It Works

1. **Compilation**: The compiler detects `<recurse>` elements and generates internal recursive render functions
2. **Type Generation**: Generates recursive TypeScript types (e.g., `Array<TreeViewState>` or `TreeViewState | null`)
3. **Runtime**:
   - For `forEach` recursion: Uses array iteration with termination when empty
   - For `accessor` recursion: Uses `withData` with built-in null checking
4. **Context Switching**: Each recursive call operates on the child's data context
5. **Safe Termination**: Recursion automatically stops at leaf nodes (empty arrays or null values)

#### Validation Rules

- **Array recursion** (`<recurse>` without accessor): Must be inside a `forEach` loop
- **Accessor recursion** (`<recurse accessor="path">`): Self-guarding via built-in null checks, no explicit guard required
- **Reference validation**: The `ref` attribute must exist as an ancestor element
- **Type safety**: Data types must match between parent and recursive child

#### When to Use Recursive Structures

**Use recursive structures for:**

- File/folder trees
- Nested comments and threads
- Organization hierarchies
- Binary trees and linked lists
- DOM tree representations
- Nested menu systems

**Consider component-based recursion for:**

- Different visual styles at different depths
- Complex state management per node
- Reusable tree nodes across different contexts

### Component Rendering

Render imported components:

```html
<div>
  <!-- Simple component -->
  <button text="Click me" />

  <!-- Component with props -->
  <Item title="{item.title}" completed="{item.completed}" forEach="items" trackBy="id" />

  <!-- Headless component -->
  <div>
    <span>Count: {namedCounter.count}</span>
    <button ref="namedCounter.increment">+</button>
  </div>
</div>
```

## Async Rendering

Jay-HTML supports asynchronous data rendering with built-in loading, resolved, and error states. This enables seamless handling of promises, API calls, and other async operations directly in your templates.

### Async Data Types

Mark data properties as async using the `async` keyword in data scripts:

```html
<script type="application/jay-data">
  data:
    title: string
    async userProfile:
      name: string
      email: string
      avatar: string
    async notifications:
    - id: string
      message: string
      timestamp: string
    async status: enum (active | inactive | pending)
</script>
```

### Conditional Rendering for Async States

Use special conditional attributes to handle different promise states:

#### Loading State

Show content while the promise is pending:

```html
<div when-loading="userProfile">
  <div class="loading-spinner">Loading user profile...</div>
</div>

<div when-loading="notifications">
  <p>Fetching notifications...</p>
</div>
```

#### Resolved State

Show content when the promise resolves successfully:

```html
<div when-resolved="userProfile">
  <img src="{avatar}" alt="Avatar" />
  <h2>{name}</h2>
  <p>{email}</p>
</div>

<ul when-resolved="notifications">
  <li forEach="." trackBy="id">
    <span>{message}</span>
    <time>{timestamp}</time>
  </li>
</ul>
```

**Note**: Within `when-resolved` blocks, use `.` to refer to the resolved value, or access properties directly as shown above.

#### Error State

Show content when the promise is rejected:

```html
<div when-rejected="userProfile">
  <p>Failed to load profile: {message}</p>
  <button ref="retryProfile">Retry</button>
</div>

<div when-rejected="notifications">
  <p>Error loading notifications</p>
  <details>
    <summary>Error Details</summary>
    <pre>{name}: {message}</pre>
  </details>
</div>
```

**Error Properties**: Within `when-rejected` blocks, you have access to error properties:

- `{name}` - Error name/type
- `{message}` - Error message
- `{stack}` - Error stack trace (in development)

## References

Use `ref="name"` to create named references for component interaction:

```html
<div>
  <input ref="username" value="{user.name}" />
  <button ref="submit">Submit</button>
  <div ref="message">{message}</div>
</div>
```

### References for Imported Headless Components

For a headless component imported with a certain key, references are prefixed with that key.

```html
<div>
  <form>
    <input ref="form.username" />
    <input ref="form.password" />
    <button ref="form.submit">Login</button>
  </form>

  <div>
    <button ref="modal.close">Close</button>
    <div ref="modal.content">{modalContent}</div>
  </div>
</div>
```

## Best Practices

### 1. Structure Your Data

Organize data logically:

```html
<script type="application/jay-data">
  data:
    # User information
    user:
      name: string
      email: string
      avatar: string

    # Application state
    state:
      isLoading: boolean
      error: string
      currentView: enum (list | detail | edit)

    # Data collections
    items:
    - id: string
      title: string
      description: string
      createdAt: string
</script>
```

### 2. Use Descriptive References

Choose meaningful reference names:

```html
<!-- Good -->
<button ref="submitButton">Submit</button>
<input ref="emailInput" />
<div ref="errorMessage">{error}</div>

<!-- Avoid -->
<button ref="btn">Submit</button>
<input ref="input1" />
<div ref="msg">{error}</div>
```

### 3. Keep Templates Readable

Use proper indentation and structure:

```html
<div class="user-profile">
  <header class="profile-header">
    <img src="{user.avatar}" alt="Avatar" class="avatar" />
    <h1 class="name">{user.name}</h1>
    <p class="email">{user.email}</p>
  </header>

  <section class="profile-content" if="!state.isLoading">
    <div class="stats">
      <div class="stat">
        <span class="label">Posts</span>
        <span class="value">{user.postCount}</span>
      </div>
    </div>
  </section>
</div>
```

## Type Generation

Jay automatically generates TypeScript types from Jay-HTML files:

```typescript
// Generated from todo.jay-html
export enum FilterOfTodoViewState {
  all,
  active,
  completed,
}

export interface ShownTodoOfTodoViewState {
  id: string;
  title: string;
  isCompleted: boolean;
}

export interface TodoViewState {
  activeTodoCount: number;
  activeTodoWord: string;
  hasItems: boolean;
  noActiveItems: boolean;
  filter: FilterOfTodoViewState;
  showClearCompleted: boolean;
  newTodo: string;
  shownTodos: Array<ShownTodoOfTodoViewState>;
}

export type ItemRef<ParentVS> = MapEventEmitterViewState<ParentVS, ReturnType<typeof Item>>;
export type ItemRefs<ParentVS> = ComponentCollectionProxy<ParentVS, ItemRef<ParentVS>> &
  OnlyEventEmitters<ItemRef<ParentVS>>;

export interface TodoElementRefs {
  newTodo: HTMLElementProxy<TodoViewState, HTMLInputElement>;
  toggleAll: HTMLElementProxy<TodoViewState, HTMLInputElement>;
  filterAll: HTMLElementProxy<TodoViewState, HTMLAnchorElement>;
  filterActive: HTMLElementProxy<TodoViewState, HTMLAnchorElement>;
  filterCompleted: HTMLElementProxy<TodoViewState, HTMLAnchorElement>;
  clearCompleted: HTMLElementProxy<TodoViewState, HTMLButtonElement>;
  shownTodos: {
    items: ItemRefs<ShownTodoOfTodoViewState>;
  };
}
```

## Next Steps

Now that you understand Jay-HTML:

1. **Learn about Contract Files** - Create reusable component contracts
2. **Build Components** - Implement the logic for your Jay-HTML designs
3. **Explore Examples** - See real-world Jay-HTML patterns
4. **Master State Management** - Learn reactive state management

---

Ready to create your first component? Check out the [Component Development](./components.md) guide!
