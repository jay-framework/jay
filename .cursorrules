# Jay Framework Project Rules

## Design Log Methodology

The project follows a rigorous design log methodology for all significant features and architectural changes.

### Before Making Changes
1. **Check design logs** in `./design-log/` for existing designs and implementation notes
2. **For new features**: Create design log first, get approval, then implement
3. **Read related design logs** to understand context and constraints

### When Creating Design Logs
1. **Structure**: Background → Problem → Solution → Implementation Plan → Examples → Trade-offs → Migration → Success Criteria
2. **Be specific**: Include file paths, type signatures, validation rules
3. **Show examples**: Use ✅/❌ for good/bad patterns, include realistic code
4. **Explain why**: Don't just describe what, explain rationale and trade-offs
5. **Ask Questions (in the file)**: For anything that is not clear, or missing information

### When Implementing
1. **Follow the implementation plan** phases from the design log
2. **Write tests first** or update existing tests to match new behavior
3. **Update design log** with "Implementation Results" section as you go
4. **Document deviations**: Explain why implementation differs from design
5. **Run tests**: Include test results (X/Y passing) in implementation notes

### When Answering Questions
1. **Reference design logs** by number when relevant (e.g., "See Design Log #50")
2. **Use codebase terminology**: ViewState, Contract, JayContract, phase annotations
3. **Show type signatures**: This is a TypeScript project with heavy type usage
4. **Consider backward compatibility**: Default to non-breaking changes

### Code Style
- Use existing patterns (e.g., `Pick<>` for phase-specific types)
- Prefer compile-time validation over runtime checks
- Generate types from contracts when possible
- Include JSDoc comments for complex types
- Use factory functions for better DX (e.g., `slow()`, `fast()`, `interactive()`)

## Key Concepts

Jay is a new full-stack web framework (see `./docs` for details):

- **Contract files** (`.jay-contract`): Define component interfaces with phase annotations (`slow`/`fast`/`fast+interactive`)
- **Jay HTML** (`.jay-html`): Extended HTML templates with reactive bindings
- **ViewState**: Data/variant properties. Interactive elements go in **Refs**, not ViewState
- **Not React**: Jay doesn't use JSX or virtual DOM
- **Three main areas**: Compiler (`/packages/compiler`), Runtime (`/packages/runtime`), Full-stack (`/packages/jay-stack`)

## Project Structure

**Yarn monorepo** with packages organized by purpose:
- `/packages/compiler/` - Parsing, type generation, build tools (compiler-jay-html, rollup-plugin, vite-plugin, cli)
- `/packages/runtime/` - Browser runtime, reactivity, security (runtime, component, reactive, secure)
- `/packages/jay-stack/` - Full-stack framework (full-stack-component, dev-server, stack-server-runtime)
- `/examples/` - Working examples: `jay/counter` (start here), `jay/todo`, `jay-stack/fake-shop`
- `/design-log/` - Design documents (01-51+) with implementation history

## Testing

- **TDD approach**: Write tests before/alongside implementation
- **Location**: `test/` folders within each package
- **Runner**: `vitest` (run `yarn test` in package or root)
- **Coverage**: See design logs for test result examples (e.g., "451 tests passing")

## Common File Locations

- Type generation: `packages/compiler/compiler-jay-html/lib/contract/`
- Full-stack builder: `packages/jay-stack/full-stack-component/lib/jay-stack-builder.ts`
- Reactive primitives: `packages/runtime/reactive/lib/`
- Simplest example: `examples/jay/counter`

## File Extensions

- `.jay-html` - Template files (extended HTML with reactive bindings)
- `.jay-contract` - Contract files (YAML, defines component interface)
- `.jay-html.d.ts` / `.jay-contract.d.ts` - Generated TypeScript types
- `.test.ts` - Vitest tests

## Build Tools

- **Vite** - Primary (most examples)
- **Rollup** - Alternative (see `examples/jay/todo-rollup-build`)
- **TypeScript** - Strict mode everywhere