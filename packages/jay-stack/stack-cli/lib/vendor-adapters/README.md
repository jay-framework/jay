# Vendor Adapters

This directory contains the vendor adapter system that enables bi-directional synchronization between external design editors and Jay projects.

## Overview

The vendor adapter system allows any design tool (Figma, Wix, Penpot, etc.) to export designs to Jay format and import them back for round-trip editing.

## Architecture

```
vendor-adapters/
├── types.ts                    # Core types and VendorAdapterRegistry
├── index.ts                    # Main entry point, registry creation
└── [vendorId]/                 # One folder per vendor
    ├── types.ts                # Vendor-specific document types
    └── [vendorId]-adapter.ts   # VendorAdapter implementation
```

## How It Works

1. **External Editor** (e.g., Figma plugin) serializes its design into a vendor-specific JSON format
2. **Vendor Client** sends the JSON to the Jay Dev Server via `POST /api/design/:vendorId/export`
3. **Dev Server** routes the request to the appropriate **Vendor Adapter**
4. **Vendor Adapter** converts the vendor JSON to Jay HTML
5. **Dev Server** saves both the original JSON (source of truth) and generated Jay HTML

For the reverse flow (import):

1. **Vendor Client** requests the vendor JSON via `GET /api/design/:vendorId/import?pageUrl=...`
2. **Dev Server** returns the stored vendor JSON
3. **Vendor Client** reconstructs the design in the editor

## Creating a New Vendor Adapter

### Step 1: Create Vendor Directory

```bash
mkdir -p vendor-adapters/myeditor
```

### Step 2: Define Types

Create `myeditor/types.ts`:

```typescript
export interface MyEditorDoc {
  name: string;
  version: string;
  nodes: MyEditorNode[];
}

export interface MyEditorNode {
  id: string;
  type: string;
  properties: Record<string, any>;
  children?: MyEditorNode[];
}
```

### Step 3: Implement Adapter

Create `myeditor/myeditor-adapter.ts`:

```typescript
import { VendorAdapter, ConversionContext, ConversionResult } from '../types';
import { MyEditorDoc } from './types';

export class MyEditorAdapter implements VendorAdapter<MyEditorDoc> {
  readonly vendorId = 'myeditor';

  async convert(doc: MyEditorDoc, context: ConversionContext): Promise<ConversionResult> {
    try {
      const jayHtml = this.convertToJayHtml(doc);

      return {
        success: true,
        jayHtml,
        warnings: [],
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Conversion failed',
      };
    }
  }

  private convertToJayHtml(doc: MyEditorDoc): string {
    // Your conversion logic here
    return '<view><!-- Converted content --></view>';
  }
}
```

### Step 4: Register Adapter

Update `index.ts`:

```typescript
export * from './myeditor/myeditor-adapter';
export * from './myeditor/types';

import { MyEditorAdapter } from './myeditor/myeditor-adapter';

export function createVendorRegistry(): VendorAdapterRegistry {
  const registry = new VendorAdapterRegistry();

  registry.register(new FigmaAdapter());
  registry.register(new MyEditorAdapter()); // Add here

  return registry;
}
```

## Current Adapters

### Figma Adapter (Placeholder)

- **Vendor ID**: `figma`
- **Status**: Placeholder implementation
- **Location**: `figma/`
- **Description**: Example adapter demonstrating the structure. Needs real Figma-to-Jay conversion logic.

## VendorAdapter Interface

```typescript
interface VendorAdapter<TVendorDoc = unknown> {
  readonly vendorId: string;

  convert(vendorDoc: TVendorDoc, context: ConversionContext): Promise<ConversionResult>;
}
```

### ConversionContext

Provided to the adapter during conversion:

```typescript
interface ConversionContext {
  pageDirectory: string; // Absolute path to page directory
  pageUrl: string; // Page route (e.g., '/home')
  projectRoot: string; // Project root path
  pagesBase: string; // Pages base directory
}
```

### ConversionResult

Returned by the adapter:

```typescript
interface ConversionResult {
  success: boolean;
  jayHtml?: string; // Generated Jay HTML
  contract?: string; // Optional contract file
  error?: string; // Error message if failed
  warnings?: string[]; // Non-fatal warnings
}
```

## File Naming Convention

When a design is exported, the following files are created:

- `page.[vendorId].json` - Original vendor document (source of truth)
- `page.jay-html` - Generated Jay HTML
- `page.jay-contract` - Optional contract (if generated by adapter)

Example for Figma:

```
src/pages/home/
├── page.figma.json      # Figma source
├── page.jay-html        # Generated Jay HTML
└── page.jay-contract    # Optional contract
```

## Testing Your Adapter

### Unit Tests

Create tests in `myeditor/myeditor-adapter.test.ts`:

```typescript
import { MyEditorAdapter } from './myeditor-adapter';

describe('MyEditorAdapter', () => {
  const adapter = new MyEditorAdapter();

  it('should have correct vendorId', () => {
    expect(adapter.vendorId).toBe('myeditor');
  });

  it('should convert a simple document', async () => {
    const doc = {
      name: 'Test',
      version: '1.0',
      nodes: [],
    };

    const result = await adapter.convert(doc, {
      pageDirectory: '/tmp/test',
      pageUrl: '/test',
      projectRoot: '/project',
      pagesBase: '/project/src/pages',
    });

    expect(result.success).toBe(true);
    expect(result.jayHtml).toBeDefined();
  });
});
```

### Manual Testing

1. Start the dev server: `npx jay dev`
2. Test with curl:

```bash
# Export
curl -X POST http://localhost:3000/api/design/myeditor/export \
  -H "Content-Type: application/json" \
  -d '{"pageUrl": "/test", "vendorDoc": {"name": "Test"}}'

# Import
curl http://localhost:3000/api/design/myeditor/import?pageUrl=/test
```

## Best Practices

1. **Type Safety**: Always use TypeScript generics for your vendor document type
2. **Error Handling**: Wrap conversion logic in try-catch
3. **Incremental Development**: Start with basic elements, add complexity gradually
4. **Preserve Metadata**: Store editor-specific data for perfect round-trips
5. **Use Warnings**: Return non-fatal issues in the `warnings` array
6. **Version Your Schema**: Include version info in your vendor document

## Common Patterns

### Converting Layout Systems

Map your editor's layout to Jay's layout components:

```typescript
private convertLayout(node: MyNode): string {
  if (node.layout === 'horizontal') {
    return '<hstack>...</hstack>';
  } else if (node.layout === 'vertical') {
    return '<vstack>...</vstack>';
  }
  return '<view>...</view>';
}
```

### Handling Unsupported Elements

```typescript
private convertNode(node: MyNode, warnings: string[]): string {
  switch (node.type) {
    case 'text':
      return '<text>...</text>';
    case 'unsupported':
      warnings.push(`Unsupported node type: ${node.type}`);
      return ''; // Skip unsupported nodes
    default:
      return '<view></view>';
  }
}
```

### Generating Contracts

Only generate contracts when needed:

```typescript
private generateContract(doc: MyDoc): string | null {
  // Only generate if there are interactive elements
  if (this.hasInteractiveElements(doc)) {
    return 'page {\n  <!-- Contract tags -->\n}';
  }
  return null;
}
```

## Resources

- [Complete Vendor Integration Guide](../../docs/core/vendor-integration.md) - Full documentation
- [API Reference](../vendor-api-handlers.ts) - HTTP endpoint handlers
- [Design Document](../../design-log/59%20-%20Server-Side%20Figma%20Conversion%20and%20Bi-directional%20Sync.md) - Architecture decisions

## Contributing

When adding a new vendor adapter:

1. Create a new directory for your vendor
2. Implement the adapter with proper types
3. Add unit tests
4. Register it in `index.ts`
5. Update this README with your adapter details
6. Consider adding example vendor documents for testing

## Future Vendors

Potential vendors to support:

- **Wix Editor** - Wix Studio integration
- **Penpot** - Open-source design tool
- **Framer** - Interactive design tool
- **Webflow** - No-code builder
- **Custom Editors** - Internal design tools
