import Node from 'node-html-parser/dist/nodes/node';
import { HTMLElement, NodeType } from 'node-html-parser';
import { Import, ImportName, WithValidations } from '@jay-framework/compiler-shared';

export function isConditional(node: Node): boolean {
    return node.nodeType !== NodeType.TEXT_NODE && (node as HTMLElement).hasAttribute('if');
}

export function isForEach(node: Node): boolean {
    return node.nodeType !== NodeType.TEXT_NODE && (node as HTMLElement).hasAttribute('forEach');
}

/**
 * Check if an element is a pre-rendered slow array item (has slowForEach attribute).
 * These are generated by the slow render transform from forEach elements.
 */
export function isSlowForEach(node: Node): boolean {
    return (
        node.nodeType !== NodeType.TEXT_NODE && (node as HTMLElement).hasAttribute('slowForEach')
    );
}

/**
 * Get the slowForEach metadata from an element.
 * Returns undefined if the element doesn't have slowForEach.
 */
export function getSlowForEachInfo(node: Node):
    | {
          arrayName: string;
          jayIndex: number;
          jayTrackBy: string;
          trackBy: string;
      }
    | undefined {
    if (!isSlowForEach(node)) return undefined;

    const element = node as HTMLElement;
    const arrayName = element.getAttribute('slowForEach');
    const jayIndex = element.getAttribute('jayIndex');
    const jayTrackBy = element.getAttribute('jayTrackBy');
    const trackBy = element.getAttribute('trackBy') || 'id';

    if (!arrayName || jayIndex === null || !jayTrackBy) {
        return undefined;
    }

    return {
        arrayName,
        jayIndex: parseInt(jayIndex, 10),
        jayTrackBy,
        trackBy,
    };
}

export function isRecurse(node: Node): boolean {
    return (
        node.nodeType !== NodeType.TEXT_NODE &&
        (node as HTMLElement).rawTagName?.toLowerCase() === 'recurse'
    );
}

/**
 * Check if a recurse element requires withData (has accessor and it's not ".")
 * This is used to determine if the parent needs to be a dynamic element
 */
export function isRecurseWithData(node: Node): boolean {
    if (!isRecurse(node)) return false;
    const accessor = (node as HTMLElement).getAttribute('accessor');
    // Only needs withData if accessor is explicitly set and not "." (forEach default)
    return accessor != null && accessor !== '.';
}

export function isWithData(node: Node): boolean {
    if (node.nodeType === NodeType.TEXT_NODE) return false;
    const element = node as HTMLElement;
    if (!element.rawTagName) return false;
    return element.rawTagName.toLowerCase() === 'with-data';
}

export interface AsyncDirectiveType {
    directive?: string;
    import?: ImportName;
    name?: string;
    isAsync: boolean;
}
export const AsyncDirectiveTypes: Record<string, AsyncDirectiveType> = {
    resolved: {
        directive: 'when-resolved',
        import: Import.resolved,
        name: 'resolved',
        isAsync: true,
    },
    loading: { directive: 'when-loading', import: Import.pending, name: 'pending', isAsync: true },
    rejected: {
        directive: 'when-rejected',
        import: Import.rejected,
        name: 'rejected',
        isAsync: true,
    },
    notAsync: { isAsync: false },
} as const;

export function checkAsync(node: Node): AsyncDirectiveType {
    if (node.nodeType !== NodeType.TEXT_NODE) {
        if ((node as HTMLElement).hasAttribute(AsyncDirectiveTypes.resolved.directive))
            return AsyncDirectiveTypes.resolved;
        else if ((node as HTMLElement).hasAttribute(AsyncDirectiveTypes.loading.directive))
            return AsyncDirectiveTypes.loading;
        else if ((node as HTMLElement).hasAttribute(AsyncDirectiveTypes.rejected.directive))
            return AsyncDirectiveTypes.rejected;
    }
    return AsyncDirectiveTypes.notAsync;
}

export function ensureSingleChildElement(node: Node): WithValidations<HTMLElement> {
    const elements = node.childNodes.filter((child) => child.nodeType === NodeType.ELEMENT_NODE);
    if (elements.length === 1) {
        return new WithValidations(elements[0] as HTMLElement);
    } else
        return new WithValidations(undefined, [
            `Jay HTML Body must have a single child element, yet ${elements.length} found.`,
        ]);
}

// ============================================================
// Jay Component Prefix Helpers
// ============================================================

/**
 * The prefix for Jay component elements.
 * Components can be written as <jay:ComponentName> or <ComponentName> (deprecated).
 */
export const JAY_COMPONENT_PREFIX = 'jay:';

/**
 * Check if an element tag has the jay: prefix.
 */
export function hasJayPrefix(tagName: string): boolean {
    return tagName.startsWith(JAY_COMPONENT_PREFIX);
}

/**
 * Extract the component name from a tag, stripping the jay: prefix if present.
 * Returns the original tag name if no prefix.
 */
export function extractComponentName(tagName: string): string {
    if (hasJayPrefix(tagName)) {
        return tagName.slice(JAY_COMPONENT_PREFIX.length);
    }
    return tagName;
}

/**
 * Check if an element is a component reference.
 * A component is identified by:
 * 1. Having jay: prefix (new syntax): <jay:Counter>
 * 2. Being in the importedSymbols set (legacy syntax): <Counter>
 *
 * During migration, both syntaxes are supported.
 * Returns the component name (without prefix) if it's a component, null otherwise.
 */
export function getComponentName(tagName: string, importedSymbols: Set<string>): string | null {
    // Check for jay: prefix first (new syntax)
    if (hasJayPrefix(tagName)) {
        const componentName = extractComponentName(tagName);
        // Validate that the component is actually imported
        if (importedSymbols.has(componentName)) {
            return componentName;
        }
        // Jay-prefixed but not imported - this will be an error
        // For now, still return the name so the compiler can report the error
        return componentName;
    }

    // Legacy syntax: plain element name matching an import
    if (importedSymbols.has(tagName)) {
        return tagName;
    }

    return null;
}
